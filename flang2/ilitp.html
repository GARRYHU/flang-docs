
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>X86-64 ILI Definitions &#8212; Flang 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/haiku.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Appendix VII - Intrinsics &amp; Generics" href="symini.html" />
    <link rel="prev" title="Appendix IV - ILM Definitions" href="ilmtp.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../index.html">
          <span>Flang 1.0 documentation</span></a></h1>
        <h2 class="heading"><span>X86-64 ILI Definitions</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="ilmtp.html">Appendix IV - ILM Definitions</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="symini.html">Appendix VII - Intrinsics &amp; Generics</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="x86-64-ili-definitions">
<h1>X86-64 ILI Definitions<a class="headerlink" href="#x86-64-ili-definitions" title="Permalink to this heading">¶</a></h1>
<section id="key-to-ili-template-listing">
<h2>Key to ILI Template Listing<a class="headerlink" href="#key-to-ili-template-listing" title="Permalink to this heading">¶</a></h2>
<p><em>ILI Operand Types:</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>irlnk
</pre></div>
</div>
<p>link to previous ili with result type ir.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>splnk
</pre></div>
</div>
<p>link to previous ili with result type sp.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dplnk
</pre></div>
</div>
<p>link to previous ili with result type dp.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>arlnk
</pre></div>
</div>
<p>link to previous ili with result type ar.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>krlnk
</pre></div>
</div>
<p>link to previous ili with result type kr.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>qplnk
</pre></div>
</div>
<p>link to previous ili with result type qp.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cslnk
</pre></div>
</div>
<p>link to previous ili with result type cs.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cdlnk
</pre></div>
</div>
<p>link to previous ili with result type cd.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cqlnk
</pre></div>
</div>
<p>link to previous ili with result type cq.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>128lnk
</pre></div>
</div>
<p>link to previous ili with result type 128.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>256lnk
</pre></div>
</div>
<p>link to previous ili with result type 256.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>512lnk
</pre></div>
</div>
<p>link to previous ili with result type 512.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>x87lnk
</pre></div>
</div>
<p>link to previous ili with result type x87.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>lnk
</pre></div>
</div>
<p>link to previous ili with result type lnk.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ir
</pre></div>
</div>
<p>integer register number (for x86-64, one of the general purpose registers).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sp
</pre></div>
</div>
<p>floating-point register number.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dp
</pre></div>
</div>
<p>double-precision register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>kr
</pre></div>
</div>
<p>64 bit integer register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cs
</pre></div>
</div>
<p>single(4+4 bytes) precision complex register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cd
</pre></div>
</div>
<p>double(8+8 bytes) precision complex register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>cq
</pre></div>
</div>
<p>16x2 bytes complex register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>qp
</pre></div>
</div>
<p>16x2 bytes register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>128
</pre></div>
</div>
<p>128 bits register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>256
</pre></div>
</div>
<p>256 bits register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>512
</pre></div>
</div>
<p>512 bits register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>x87
</pre></div>
</div>
<p>80-bit x87 register.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ar
</pre></div>
</div>
<p>Address register (for x86-64, one of the general purpose registers).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>stc
</pre></div>
</div>
<p>16 bit constant.  May be interpreted as either signed or unsigned depending
on the machine instruction operand which uses it.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>nme
</pre></div>
</div>
<p>pointer to names table entry for a load or store.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sym
</pre></div>
</div>
<p>symbol table pointer.</p>
<p><em>ILI Types (1st attribute of each ILI):</em></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">arth</span></code></dt><dd><p>arithmetic operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">branch</span></code></dt><dd><p>branch operation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">cons</span></code></dt><dd><p>constant.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">load</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">store</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">define</span></code></dt><dd><p>register define.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">proc</span></code></dt><dd><p>function call.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">move</span></code></dt><dd><p>register move.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">other</span></code></p>
<p><em>Commutivity attribute (2nd attribute of each ILI):</em>
.CM comm
Commutative operation.
.CM null
Not commutative.</p>
<p><em>ILI result type (3rd attribute of each ILI):</em>
.RT lnk
no result, but ili is pointed-to by link.
.RT ir
result goes into an integer register.
.RT sp
result goes into a floating-point register.
.RT dp
double-precision floating-point.
.RT ar
address register result.
.RT trm
this ili does not produce a value and cannot be pointed to by any
link operand of another ili.</p>
<p><em>Other ILI Attributes:</em>
.IA dom
specifies that this ili is a dominator ili.
.IA cse
specifies that this ili is a candidate for constant subexpression elimination.
An ili is not allowed to have both the cse and the dom attributes.
.IA ssenme
indicates that this is an sse operation with operand 1 an arlnk field and
operand 3 a nme field.</p>
<p><em>Code Generator ILI Attributes (x86-64 compilers):</em>
.CA notCG
ili opcode never used within the code generator, though it may process
such an ili while linearizing the shared ili form.
.CA CGonly
ili is created and used only by the code generator.
.CA notAILI
opcode which should not appear in the AILI (set automatically if notCG
is specified).
.CA replaceby
specifies opcode which replaces this one during linearization.
.CA terminal
specifies ili for which code_gen is called directly from cgmain.
.CA move
Indicates aili which can be eliminated if src1 is the same as dest.
.CA conditional_branch
.CA asm_special
during generation of assembly code by the code generator,
this opcode is treated as a special case.
.CA asm_nop
No assembly output is required for this aili.</p>
</section>
<section id="ili-definitions">
<h2>ILI Definitions<a class="headerlink" href="#ili-definitions" title="Permalink to this heading">¶</a></h2>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ICON</span></code></dt><dd><p>32-bit integer constant.</p>
<p>The value is pulled from the CONVAL2 field of sym.</p>
<p><em>Attributes</em>: cons null ir cse
.CG “mov” ‘l’<em>direct</em> lat(1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACON</span></code></dt><dd><p>Load address constant into address register.
'sym’ must be a symtab ptr to an address constant.</p>
<p><em>Attributes</em>: cons null ar cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACON_PIC_EXTRN</span></code></dt><dd><p>Address constant used for PIC generation.  It represents the load
of the address of an external variable from the GOTPCREL table.
'sym’ is the symbol table pointer for the external variable, NOT
an address constant symbol.</p>
<p><em>Attributes</em>: cons null ar cse
.CG CGonly “mov” ‘q’ asm_special*direct* lat(1)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACON_STATIC</strong> sym    <em>Type</em>: <em>sym</em></p>
<p>Used in the linear ili to represent an address constant with
a full 64-bit offset.  The first sym points to a static or external
variable, or a label, and the second to a symbol table 64-bit integer constant.</p>
<p><em>Attributes</em>: cons null ar cse
.CG CGonly “lea” ‘q’<em>direct</em> lat(2)</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACON_TLS</span></code></dt><dd><p>Load a TLS immediate address
'sym’ must be a symtab ptr to an address constant.</p>
<p><em>Attributes</em>: cons null ar
.CG CGonly “lea” ‘q’ asm_special*direct* lat(1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACON_TLS_PIC</span></code></dt><dd><p>Load a TLS address that is stored as a PIC value
'sym’ is the symbol table pointer for the external variable, NOT
an address constant symbol.</p>
<p><em>Attributes</em>: cons null ar
.CG CGonly “lea” ‘q’ asm_special*direct* lat(1)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACON_AUTO</strong> sym    <em>Type</em>: <em>sym</em></p>
<p>Same as ACON_STATIC, but the first sym is a stack variable.</p>
<p><em>Attributes</em>: cons null ar cse
.CG CGonly “lea” ‘q’<em>direct</em> lat(2)</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">KCON</span></code></dt><dd><p>64-bit integer constant.  ‘sym’ is a symbol table constant of type
DT_INT or DT_INT8.</p>
<p><em>Attributes</em>: cons null kr cse
.CG “mov” ‘q’<em>direct</em> lat(1)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACEXT</strong> nme    <em>Type</em>: <em>sym</em></p>
<p>Label address.
'sym’ is address constant for label symbol.
'nme’ is zero.</p>
<p><em>Attributes</em>: cons null ar cse
.CG “mov”<em>direct</em> lat(1)</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FCON</span></code></dt><dd><p>Single-precision floating-point constant.</p>
<p><em>Attributes</em>: cons null sp cse
.CG “movss” move avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCON</span></code></dt><dd><p>Double-precision floating-point constant.</p>
<p><em>Attributes</em>: cons null dp cse
.CG “movsd” move avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXCON</span></code></dt><dd><p>Single-precision complex constant.</p>
<p><em>Attributes</em>: cons null cs cse
.CG “movsd” move avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXCON</span></code></dt><dd><p>Double-precision complex constant.</p>
<p><em>Attributes</em>: cons null cd cse
.CG “movapd” move sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>LD</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>'arlnk’ points to an address expression.</p>
<p>'nme’ points to the names table entry of the variable being referenced.</p>
<p>'stc’ size modifier of the memory operation - one of the MSZ_ macros
defined in ili.h.
For the code generator, possible values are:</p>
<blockquote>
<div><p>MSZ_SBYTE    signed byte
MSZ_UBYTE    unsigned byte
MSZ_SHWORD   signed half-word
MSZ_UHWORD   unsigned half-word
MSZ_SWORD    signed word (32-bit)
MSZ_UWORD    unsigned word</p>
</div></blockquote>
<p><em>Attributes</em>: load null ir
.CG “mov” move*direct* lat(1)</p>
<p><em>ld</em> direct lat(3)</p>
<p><em>st</em> direct lat(3)</p>
</li>
<li><p><strong>LDSP</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load single-precision floating value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null sp
.CG “movss” move avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</li>
<li><p><strong>LDDP</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load double precision value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null dp
.CG “movsd” move avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>LDSCMPLX</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load single precision complex value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null cs
.CG “movsd” move avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>LDDCMPLX</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load double precision complex value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null cd
.CG “movupd” move sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>LDQ</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load an __m128 value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null dp
.CG “movapd” move sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>LDQU</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load an unaligned __m128 value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null dp
.CG “movupd” move sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>LD256</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load an __m256 value.  ‘stc’ is not used.
May generate a LD256U.</p>
<p><em>Attributes</em>: load null dp
.CG “vmovapd” ‘y’ move avx_only*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>LD256A</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load an aligned __m256 value.  ‘stc’ is not used.
Will generate the aligned case for LD256.</p>
<p><em>Attributes</em>: load null dp
.CG notAILI</p>
</li>
<li><p><strong>LD256U</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load an unaligned __m256 value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null dp
.CG “vmovupd” ‘y’ move avx_only*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>LD512</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load an __m512 value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null 512
.CG “vmovupd” ‘z’ move avx_only*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>LDA</strong> nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load address register from memory location whose address
is represented by op1.
For x86-64 compilers, LDA’s are replaced by LDKR’s by cgoptim1.</p>
<p><em>Attributes</em>: load null ar
.CG notAILI</p>
</li>
<li><p><strong>LDKR</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load 64 bit integer value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null kr
.CG notAILI</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">INEG</span></code></dt><dd><p>Signed integer32 negate.</p>
<p><em>Attributes</em>: arth null ir cse
.CG memdest ccarith “neg” ‘l’<em>direct</em> lat(4:1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UINEG</span></code></dt><dd><p>Unsigned integer32 negate.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG replaceby INEG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KNEG</span></code></dt><dd><p>Signed integer64 negate.</p>
<p><em>Attributes</em>: arth null kr cse
.CG memdest ccarith “neg” ‘q’<em>direct</em> lat(4:1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UKNEG</span></code></dt><dd><p>Unsigned integer64 negate.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG replaceby KNEG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FNEG</span></code></dt><dd><p>Real*4 negation.  This LILI is replaced by an FXOR LILI in
cgoptim1.c:lili_peephole_opts_2().</p>
<p><em>Attributes</em>: arth null sp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DNEG</span></code></dt><dd><p>Real*8 negation.  This LILI is replaced by a DXOR LILI in
cgoptim1.c:lili_peephole_opts_2().</p>
<p><em>Attributes</em>: arth null dp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXNEG</span></code></dt><dd><p>Complex*8 negation.  This LILI is replaced by an SCMPLXXOR LILI in
cgoptim1.c:lili_peephole_opts_2().</p>
<p><em>Attributes</em>: arth null cs cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXNEG</span></code></dt><dd><p>Complex*16 negation.  This LILI is replaced by a DCMPLXXOR LILI in
cgoptim1.c:lili_peephole_opts_2().</p>
<p><em>Attributes</em>: arth null cd cse
.CG notAILI</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>FXOR</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>This only appears in the LILIs and AILIs, not in shared ILIs.  It is
generated in cgoptim1.c:lili_peephole_opts_2() by transforming
FNEG( op1 ) into an FXOR LILI in order to negate ‘op1’ by XORing its
sign bit with 1.  This ILI is specified as non-commutative
(i.e. ‘null’, not ‘comm’) for reasons explained in that function.</p>
<p><em>Attributes</em>: arth null sp cse
.CG CGonly “xorps” sse_avx</p>
</li>
<li><p><strong>DXOR</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>This only appears in the LILIs and AILIs, not in shared ILIs.  It is
generated in cgoptim1.c:lili_peephole_opts_2() by transforming
DNEG( op1 ) into a DXOR LILI in order to negate ‘op1’ by XORing its
sign bit with 1.  This ILI is specified as non-commutative
(i.e. ‘null’, not ‘comm’) for reasons explained in that function.</p>
<p><em>Attributes</em>: arth null dp cse
.CG CGonly “xorpd” sse_avx*double* fmul lat(5:3)</p>
</li>
<li><p><strong>SCMPLXXOR</strong> cslnk    <em>Type</em>: <em>cslnk</em></p>
<p>This only appears in the LILIs and AILIs, not in shared ILIs.  It is
generated in cgoptim1.c:lili_peephole_opts_2() by transforming
SCMPLXNEG( op1 ) into an SCMPLXXOR LILI in order to negate ‘op1’ by
XORing its sign bits with 1.  This ILI is specified as non-commutative
(i.e. ‘null’, not ‘comm’) for reasons explained in that function.</p>
<p><em>Attributes</em>: arth null cs cse
.CG CGonly “xorps” sse_avx</p>
</li>
<li><p><strong>DCMPLXXOR</strong> cdlnk    <em>Type</em>: <em>cdlnk</em></p>
<p>This only appears in the LILIs and AILIs, not in shared ILIs.  It is
generated in cgoptim1.c:lili_peephole_opts_2() by transforming
DCMPLXNEG( op1 ) into a DCMPLXXOR LILI in order to negate ‘op1’ by
XORing its sign bits with 1.  This ILI is specified as non-commutative
(i.e. ‘null’, not ‘comm’) for reasons explained in that function.</p>
<p><em>Attributes</em>: arth null cd cse
.CG CGonly “xorpd” sse_avx</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXCONJG</span></code></dt><dd><p>Single-precision complex conjugate.</p>
<p><em>Attributes</em>: arth null cs cse
.CG “xorps” sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXCONJG</span></code></dt><dd><p>Double-precision complex conjugate.</p>
<p><em>Attributes</em>: arth null cd cse
.CG “xorpd” sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IABS</span></code></dt><dd><p>Integer absolute value.  Expanded into shift-xor-sub sequence.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KABS</span></code></dt><dd><p>Integer64 absolute value.  Expanded into shift-xor-sub sequence.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FABS</span></code></dt><dd><p>Real (single-precision) absolute value.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notAILI</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>FAND</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>This is generated either in iliutil.c:addarth() to implement an
approximate scalar FSQRT or in cglinear.c:gen_lilis() to compute
FABS( op1 ) by clearing ‘op1’s sign bit.  This ILI is specified as
non-commutative (i.e. ‘null’, not ‘comm’) for the same reason that
FXOR is non-commutative.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “andps” sse_avx*double* fmul lat(5:3)</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DABS</span></code></dt><dd><p>Double precision absolute value.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notAILI</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>DAND</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>This only appears in the LILIs and AILIs, not in shared ILIs.  It is
generated in cglinear.c:gen_lilis() by transforming a DABS( op1 ) ILI
into a DAND LILI which computes the absolute value of ‘op1’ by
clearing its sign bit.  This ILI is specified as non-commutative
(i.e. ‘null’, not ‘comm’) for the same reason that DXOR is
non-commutative.</p>
<p><em>Attributes</em>: arth null dp cse
.CG CGonly “andpd” sse_avx*direct* fadd lat(5:3)</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">NOT</span></code></dt><dd><p>32 bit bitwise not.</p>
<p><em>Attributes</em>: arth null ir cse
.CG memdest “not” ‘l’<em>direct</em> lat(4:1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UNOT</span></code></dt><dd><p>Unsigned bitwise negation of 32 bit bitwise not.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG replaceby NOT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KNOT</span></code></dt><dd><p>64 bit bitwise not.</p>
<p><em>Attributes</em>: arth null kr cse
.CG memdest “not” ‘q’<em>direct</em> lat(4:1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UKNOT</span></code></dt><dd><p>64 bit bitwise not.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG replaceby KNOT</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FSQRT</span></code></dt><dd><p>Single-precision floating-point square root.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “sqrtss” avx_special*direct* fmul lat(21:19)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DSQRT</span></code></dt><dd><p>Double-precision square root.</p>
<p><em>Attributes</em>: arth null dp cse
.CG “sqrtsd” avx_special*direct* fmul lat(29:27)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FRSQRT</span></code></dt><dd><p>Single-precision floating-point reciprocal square root.
1.0/sqrt(x) – will be replaced by the Newton’s appx via the
ALT field</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RCPSS</span></code></dt><dd><p>Single-precision approximation to reciprocal.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “rcpss” avx_special*direct* fmul lat(21:19)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">RSQRTSS</span></code></dt><dd><p>Single-precision approximation to reciprocal square root.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “rsqrtss” avx_special*direct* fmul lat(21:19)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>CMPNEQSS</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Used for single-precision square root approximation.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “cmpneqss” sse_avx</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FNSIN</span></code></dt><dd><p>Utility ili: only referenced by the ‘alt’ field of an FSIN ili;
always points to an FSINCOS ili.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DNSIN</span></code></dt><dd><p>Utility ili: only referenced by the ‘alt’ field of an DSIN ili;
always points to an DSINCOS ili.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FSIN</span></code></dt><dd><p>Single precision floating point sine.  Implemented as a function call.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DSIN</span></code></dt><dd><p>Double precision sine.  Implemented as a function call.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FNCOS</span></code></dt><dd><p>Utility ili: only referenced by the ‘alt’ field of an FCOS ili;
always points to an FSINCOS ili.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DNCOS</span></code></dt><dd><p>Utility ili: only referenced by the ‘alt’ field of an DCOS ili;
always points to an DSINCOS ili.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FCOS</span></code></dt><dd><p>Single precision floating point cosine.  Implemented as library call.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCOS</span></code></dt><dd><p>Double precision cosine.  Implemented as library call.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FSINCOS</span></code></dt><dd><p>Used to implement SINCOS optimization (single precision).</p>
<p><em>Attributes</em>: arth null sp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DSINCOS</span></code></dt><dd><p>Used to implement SINCOS optimization (double precision).</p>
<p><em>Attributes</em>: arth null dp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FTAN</span></code></dt><dd><p>Single-precision floating-point tangent.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DTAN</span></code></dt><dd><p>Double-precision tangent.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FLOG</span></code></dt><dd><p>Single-precision floating-point natural logarithm.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DLOG</span></code></dt><dd><p>Double-precision natural logarithm.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FLOG10</span></code></dt><dd><p>Single-precision floating-point common logarithm.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DLOG10</span></code></dt><dd><p>Double-precision common logarithm.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FEXP</span></code></dt><dd><p>Single-precision floating-point exponential.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEXP</span></code></dt><dd><p>Double-precision exponential.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FACOS</span></code></dt><dd><p>Single-precision floating-point arccosine.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DACOS</span></code></dt><dd><p>Double-precision  arccosine.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FASIN</span></code></dt><dd><p>Single-precision floating-point arcsine.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DASIN</span></code></dt><dd><p>Double-precision  arcsine.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FATAN</span></code></dt><dd><p>Single-precision floating-point arctangent.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DATAN</span></code></dt><dd><p>Double-precision  arctangent.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>FATAN2</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single-precision floating-point two-argument arctangent.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>DATAN2</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double-precision two-argument arctangent.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FSINH</span></code></dt><dd><p>Single-precision floating-point hyperbolic sin</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DSINH</span></code></dt><dd><p>Double-precision hyperbolic sin</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FCOSH</span></code></dt><dd><p>Single-precision floating-point hyperbolic cos</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCOSH</span></code></dt><dd><p>Double-precision hyperbolic cos</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FTANH</span></code></dt><dd><p>Single-precision floating-point hyperbolic tan</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DTANH</span></code></dt><dd><p>Double-precision hyperbolic tan</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>FNEWT</strong> splnk splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single-precision floating-point multiply used for single divides.
Not used by the x86-64 compilers.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>DNEWT</strong> dplnk dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double-precision floating-point multiply used for double divides.
Not used by the x86-64 compilers.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">NINT</span></code></dt><dd><p>Real NINT.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KNINT</span></code></dt><dd><p>Real NINT.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IDNINT</span></code></dt><dd><p>Double NINT.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KIDNINT</span></code></dt><dd><p>Double NINT.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ISIGN</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Integer sign intrinsic.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>SIGN</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Real sign.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>DSIGN</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double sign.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</li>
<li><p><strong>IDIM</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Integer dim intrinsic.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>FDIM</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Real dim.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>DDIM</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double dim.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FFLOOR</span></code></dt><dd><p>Real FLOOR.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “roundss” sse_avx</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DFLOOR</span></code></dt><dd><p>Double FLOOR.</p>
<p><em>Attributes</em>: arth null dp cse
.CG “roundsd” sse_avx</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FCEIL</span></code></dt><dd><p>Real CEILING.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “roundss” sse_avx</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCEIL</span></code></dt><dd><p>Double CEILING.</p>
<p><em>Attributes</em>: arth null dp cse
.CG “roundsd” sse_avx</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AINT</span></code></dt><dd><p>Single precision trunction.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DINT</span></code></dt><dd><p>Double precision trunction.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXEXP</span></code></dt><dd><p>Single-precision complex exponential.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXEXP</span></code></dt><dd><p>Double-precision complex exponential.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXCOS</span></code></dt><dd><p>Single-precision complex cosine.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXCOS</span></code></dt><dd><p>Double-precision complex cosine.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXSIN</span></code></dt><dd><p>Single-precision complex sine.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXSIN</span></code></dt><dd><p>Double-precision complex sine.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXTAN</span></code></dt><dd><p>Single-precision complex tangent.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXTAN</span></code></dt><dd><p>Double-precision complex tangent.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXACOS</span></code></dt><dd><p>Single-precision complex arccosine.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXACOS</span></code></dt><dd><p>Double-precision complex arccosine.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXASIN</span></code></dt><dd><p>Single-precision complex arcsine.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXASIN</span></code></dt><dd><p>Double-precision complex arcsine.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXATAN</span></code></dt><dd><p>Single-precision complex arctangent.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXATAN</span></code></dt><dd><p>Double-precision complex arctangent.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXCOSH</span></code></dt><dd><p>Single-precision complex hyperbolic cos.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXCOSH</span></code></dt><dd><p>Double-precision complex hyperbolic cos.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXSINH</span></code></dt><dd><p>Single-precision complex hyperbolic sin.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXSINH</span></code></dt><dd><p>Double-precision complex hyperbolic sin.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXTANH</span></code></dt><dd><p>Single-precision complex hyperbolic tan.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXTANH</span></code></dt><dd><p>Double-precision complex hyperbolic tan.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXLOG</span></code></dt><dd><p>Single-precision complex natural logarithm.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXLOG</span></code></dt><dd><p>Double-precision complex natural logarithm.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLXSQRT</span></code></dt><dd><p>Single-precision complex square root.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLXSQRT</span></code></dt><dd><p>Double-precision complex square root.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>SCMPLXPOW</strong> cslnk    <em>Type</em>: <em>cslnk</em></p>
<p>Single-precision complex raised to a single-precision complex power.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</li>
<li><p><strong>DCMPLXPOW</strong> cdlnk    <em>Type</em>: <em>cdlnk</em></p>
<p>Double-precision complex raised to a double-precision complex power.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</li>
<li><p><strong>SCMPLXPOWI</strong> irlnk    <em>Type</em>: <em>cslnk</em></p>
<p>Single-precision complex raised to an integer power.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</li>
<li><p><strong>DCMPLXPOWI</strong> irlnk    <em>Type</em>: <em>cdlnk</em></p>
<p>Double-precision complex raised to an integer power.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</li>
<li><p><strong>SCMPLXPOWK</strong> krlnk    <em>Type</em>: <em>cslnk</em></p>
<p>Single-precision complex raised to an integer power.</p>
<p><em>Attributes</em>: arth null cs cse
.CG notCG</p>
</li>
<li><p><strong>DCMPLXPOWK</strong> krlnk    <em>Type</em>: <em>cdlnk</em></p>
<p>Double-precision complex raised to an integer power.</p>
<p><em>Attributes</em>: arth null cd cse
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ITOUI</span></code></dt><dd><p>Integer to unsigned integer conversion.
Treated as a nop by linearization.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UITOI</span></code></dt><dd><p>Unsigned integer to integer conversion.
Treated as a nop by linearization.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">IKMV</span></code></dt><dd><p>Signed integer*4 to signed or unsigned integer*8 type conversion.</p>
<p><em>Attributes</em>: move null kr cse
.CG asm_special “movslq” ‘q’<em>ld</em> direct lat(1)</p>
<p><em>st</em> direct lat(4)</p>
<p><em>direct</em> lat(1)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PIKMV</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert ‘N’ packed signed integer*4 values from ‘arlnk’ into ‘N’
packed signed or unsigned integer*8 values in ‘xmm’, where ‘N’ is 2, 4
or 8 if ‘xmm’ is an xmm (&gt;= SSE4.1), ymm (&gt;= AVX2) or zmm (AVX-512)
register respectively.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pmovsxdq” sse_avx</p>
</li>
<li><p><strong>PIKMVX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert ‘N’ packed signed integer*4 values from ‘xmm1’ (an xmm or ymm
register) into ‘N’ packed signed or unsigned integer*8 values in
‘xmm2’ (an xmm, ymm or zmm register), where ‘N’ is 2, 4 or 8 if ‘xmm2’
is an xmm (&gt;= SSE4.1), ymm (&gt;= AVX2) or zmm (AVX-512) register
respectively.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pmovsxdq” avx_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">UIKMV</span></code></dt><dd><p>Unsigned integer*4 to signed or unsigned integer*8 type conversion.</p>
<p><em>Attributes</em>: move null kr cse
.CG asm_special “movl” ‘q’</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PUIKMV</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert ‘N’ packed unsigned integer*4 values from ‘arlnk’ into ‘N’
packed signed or unsigned integer*8 values in ‘xmm’, where ‘N’ is 2, 4
or 8 if ‘xmm’ is an xmm (&gt;= SSE4.1), ymm (&gt;= AVX2) or zmm (AVX-512)
register respectively.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pmovzxdq” sse_avx</p>
</li>
<li><p><strong>PUIKMVX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert ‘N’ packed unsigned integer*4 values from ‘xmm1’ (an xmm or
ymm register) into ‘N’ packed signed or unsigned integer*8 values in
‘xmm2’ (an xmm, ymm or zmm register), where ‘N’ is 2, 4 or 8 if ‘xmm2’
is an xmm (&gt;= SSE4.1), ymm (&gt;= AVX2) or zmm (AVX-512) register
respectively.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pmovzxdq” avx_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">KIMV</span></code></dt><dd><p>Signed or unsigned integer*8 to signed or unsigned integer*4 type
conversion with truncation.  Note, we mustn’t treat this as a move for
the purposes of register allocation.</p>
<p><em>Attributes</em>: move null ir cse
.CG “mov” ‘l’<em>direct</em> lat(1)</p>
<p><em>ld</em> direct lat(3)</p>
<p><em>st</em> direct lat(3)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PKIMVX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Truncate ‘N’ packed signed or unsigned integer*8 values from ‘xmm1’
(an xmm, ymm or zmm register) into ‘N’ packed signed or unsigned
integer*4 values in ‘xmm2’ (an xmm or ymm register), where ‘N’ is 2, 4
or 8 if ‘xmm1’ is an xmm, ymm or zmm register respectively.  This
instruction requires support for AVX-512F and AVX-512VL, and the
source operand must be a register (unusually for AVX instructions the
destination can be a memory operand!).</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vpmovqd” avx_only avx_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">IAMV</span></code></dt><dd><p>Move an integer reg into an address reg.
Sign extension required?</p>
<p><em>Attributes</em>: move null ar cse
.CG notCG replaceby IKMV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AIMV</span></code></dt><dd><p>Move an address register to a integer register.
Truncation required.</p>
<p><em>Attributes</em>: move null ir cse
.CG notCG replaceby KIMV</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KAMV</span></code></dt><dd><p>Move an 64 bit integer reg into an address reg.
Treated as a nop by Linearize.</p>
<p><em>Attributes</em>: move null ar cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">AKMV</span></code></dt><dd><p>Move an address register to a 64 bit integer register.
Treated as a nop in Linearize.</p>
<p><em>Attributes</em>: move null kr cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOVSB</span></code></dt><dd><p>Load a signed byte into a 32 or 64 bit register.</p>
<p><em>Attributes</em>: move null ir
.CG CGonly asm_special “movsb” ‘l’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOVSBQ</span></code></dt><dd><p>Load a signed byte into a 64 bit register.  (JHM, 1 Oct 2013: Redundant?)</p>
<p><em>Attributes</em>: move null kr
.CG CGonly asm_special “movsb” ‘q’</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PMOVSB</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert ‘N’ packed signed byte values from ‘arlnk’ into ‘N’ packed
integer*4 values in ‘xmm’, where ‘N’ is 4, 8 or 16 if ‘xmm’ is an xmm
(&gt;= SSE4.1), ymm (&gt;= AVX2) or zmm (AVX-512) register respectively.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pmovsxbd” sse_avx</p>
</li>
<li><p><strong>PMOVSBX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert ‘N’ packed signed byte values from ‘xmm1’ (an xmm register)
into ‘N’ packed integer*4 values in ‘xmm2’ (an xmm, ymm or zmm
register), where ‘N’ is 4, 8 or 16 if ‘xmm2’ is an xmm (&gt;= SSE4.1),
ymm (&gt;= AVX2) or zmm (AVX-512) register respectively.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pmovsxbd” avx_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">MOVZB</span></code></dt><dd><p>Load an unsigned byte into a 32 or 64 bit register.</p>
<p><em>Attributes</em>: move null ir
.CG CGonly asm_special “movzb” ‘l’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOVZBQ</span></code></dt><dd><p>Load an unsigned byte into a 64 bit register.  (JHM, 1 Oct 2013: Redundant?)</p>
<p><em>Attributes</em>: move null kr
.CG CGonly asm_special “movzb” ‘q’</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PMOVZB</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert ‘N’ packed unsigned byte values from ‘arlnk’ into ‘N’ packed
integer*4 values in ‘xmm’, where ‘N’ is 4, 8 or 16 if ‘xmm’ is an xmm
(&gt;= SSE4.1), ymm (&gt;= AVX2) or zmm (AVX-512) register respectively.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pmovzxbd” sse_avx</p>
</li>
<li><p><strong>PMOVZBX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert ‘N’ packed unsigned byte values from ‘xmm1’ (an xmm register)
into ‘N’ packed integer*4 values in ‘xmm2’ (an xmm, ymm or zmm
register), where ‘N’ is 4, 8 or 16 if ‘xmm2’ is an xmm (&gt;= SSE4.1),
ymm (&gt;= AVX2) or zmm (AVX-512) register respectively.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pmovzxbd” avx_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">MOVSW</span></code></dt><dd><p>Load a signed integer*2 value into a 32 or 64 bit register.</p>
<p><em>Attributes</em>: move null ir
.CG CGonly asm_special “movsw” ‘l’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOVSWQ</span></code></dt><dd><p>Load a signed integer*2 value into a 64 bit register.
(JHM, 1 Oct 2013: Redundant?)</p>
<p><em>Attributes</em>: move null kr
.CG CGonly asm_special “movsw” ‘q’</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PMOVSW</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert ‘N’ packed signed integer*2 values from ‘arlnk’ into ‘N’
packed integer*4 values in ‘xmm’, where ‘N’ is 4, 8 or 16 if ‘xmm’ is
an xmm (&gt;= SSE4.1), ymm (&gt;= AVX2) or zmm (AVX-512) register
respectively.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pmovsxwd” sse_avx</p>
</li>
<li><p><strong>PMOVSWX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert ‘N’ packed signed integer*2 values from ‘xmm1’ (an xmm or ymm
register) into ‘N’ packed integer*4 values in ‘xmm2’ (an xmm, ymm or
zmm register), where ‘N’ is 4, 8 or 16 if ‘xmm2’ is an xmm (&gt;= SSE4.1),
ymm (&gt;= AVX2) or zmm (AVX-512) register respectively.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pmovsxwd” avx_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">MOVZW</span></code></dt><dd><p>Load an unsigned integer*2 value into a 32 or 64 bit register.</p>
<p><em>Attributes</em>: move null ir
.CG CGonly asm_special “movzw” ‘l’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOVZWQ</span></code></dt><dd><p>Load an unsigned integer*2 value into a 64 bit register.
(JHM, 1 Oct 2013: Redundant?)</p>
<p><em>Attributes</em>: move null kr
.CG CGonly asm_special “movzw” ‘q’</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PMOVZW</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert ‘N’ packed unsigned integer*2 values from ‘arlnk’ into ‘N’
packed integer*4 values in ‘xmm’, where ‘N’ is 4, 8 or 16 if ‘xmm’ is
an xmm (&gt;= SSE4.1), ymm (&gt;= AVX2) or zmm (AVX-512) register
respectively.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pmovzxwd” sse_avx</p>
</li>
<li><p><strong>PMOVZWX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert ‘N’ packed unsigned integer*2 values from ‘xmm1’ (an xmm or
ymm register) into ‘N’ packed integer*4 values in ‘xmm2’ (an xmm, ymm
or zmm register), where ‘N’ is 4, 8 or 16 if ‘xmm2’ is an xmm (&gt;= SSE4.1),
ymm (&gt;= AVX2) or zmm (AVX-512) register respectively.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pmovzxwd” avx_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FLOAT</span></code></dt><dd><p>Integer*4 to real*4 type conversion.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “cvtsi2ss” ‘l’ sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PFLOAT</span></code></dt><dd><p>Packed integer*4 to real*4 type conversion.  ONLY USED ON x86-64.
WE SHOULD DELETE THIS AND USE PSFLOAT INSTEAD.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “cvtdq2ps” ‘l’ sse_avx asm_special</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PSFLOAT</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert 4 integer*4 values from ‘arlnk’ into 4 real*4 values in ‘xmm’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “cvtdq2ps” sse_avx</p>
</li>
<li><p><strong>PSFLOATX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert 4 integer*4 values from ‘xmm1’ into 4 real*4 values in ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “cvtdq2ps” sse_avx</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FLOATU</span></code></dt><dd><p>Unsigned integer*4 to real*4 type conversion.
Equivalent to UIKMV + FLOATK combination.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FLOATK</span></code></dt><dd><p>Integer*8 to real*4 type conversion.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “cvtsi2ss” ‘q’ avx_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FLOATUK</span></code></dt><dd><p>Unsigned integer*8 to real*4 type conversion.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DFLOAT</span></code></dt><dd><p>Integer*4 to real*8 type conversion.</p>
<p><em>Attributes</em>: arth null dp cse
.CG “cvtsi2sd” ‘l’ sse_avx asm_special*ld* direct fst lat(6)</p>
<p><em>double</em> fst lat(11)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PDFLOAT</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert ‘N’ packed signed integer*4 values from ‘arlnk’ into ‘N’
packed real*8 values in ‘xmm’, where ‘N’ is 2, 4 or 8 if ‘xmm’ is an
xmm (&gt;= SSE2), ymm (&gt;= AVX) or zmm (AVX-512F) register respectively.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “cvtdq2pd” ssedp sse_avx</p>
</li>
<li><p><strong>PDFLOATX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert ‘N’ packed signed integer*4 values from ‘xmm1’ (an xmm or ymm
register) into ‘N’ packed real*8 values in ‘xmm2’ (an xmm, ymm or zmm
register), where ‘N’ is 2, 4 or 8 if ‘xmm’ is an xmm (&gt;= SSE2), ymm
(&gt;= AVX) or zmm (AVX-512F) register respectively.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “cvtdq2pd” ssedp avx_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DFLOATU</span></code></dt><dd><p>Unsigned integer*4 to real*8 type conversion.
Equivalent to UIKMV + DFLOATK combination.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DFLOATK</span></code></dt><dd><p>Integer*8 to real*8 type conversion.</p>
<p><em>Attributes</em>: arth null dp cse
.CG “cvtsi2sd” ‘q’ avx_special*ld* direct fst lat(6)</p>
<p><em>double</em> fst lat(11)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DFLOATUK</span></code></dt><dd><p>Unsigned integer*8 to real*8 type conversion.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notAILI</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PDFLOATK</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>AVX512-DQ instruction to convert packed integer*8 values from ‘arlnk’
into real*8 values in ‘xmm’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal notAILI</p>
</li>
<li><p><strong>PDFLOATKX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>AVX512-DQ instruction to convert packed integer*8 values from ‘xmm1’
into real*8 values in ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal notAILI</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FIX</span></code></dt><dd><p>Real*4 to integer*4 type conversion.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “cvttss2si” ‘l’ sse_avx asm_special*ld* vector fst lat(10)</p>
<p><em>double</em> fst lat(9)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">UFIX</span></code></dt><dd><p>Real*4 to unsigned integer*4 type conversion.  Equivalent to FIXK +
KIMV combination.</p>
<p><em>Attributes</em>: arth null ir
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PSFIX</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert 4 real*4 values from ‘arlnk’ into 4 integer*4 values in ‘xmm’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “cvttps2dq” sse_avx</p>
</li>
<li><p><strong>PSFIXX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert 4 real*4 values from ‘xmm1’ into 4 integer*4 values in ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “cvttps2dq” sse_avx</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FIXK</span></code></dt><dd><p>Real*4 to integer*8 type conversion.</p>
<p><em>Attributes</em>: arth null kr cse
.CG “cvttss2si” ‘q’ sse_avx asm_special*ld* vector fst lat(10)</p>
<p><em>double</em> fst lat(9)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">FIXUK</span></code></dt><dd><p>Real*4 to unsigned integer*8 type conversion.  Implemented as a QJSR.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DFIX</span></code></dt><dd><p>Real*8 to integer*4 type conversion.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “cvttsd2si” ‘l’ sse_avx asm_special*double* fst lat(9)</p>
<p><em>ld</em> vector fadd fmul fstore lat(10)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DFIXU</span></code></dt><dd><p>Real*8 to unsigned integer*4 type conversion.  Equivalent to DFIXK +
KIMV combination.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PDFIX</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert 2 real*8 values from ‘arlnk’ into 2 integer*4 values in the
low half of ‘xmm’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “cvttpd2dq” avx_special</p>
</li>
<li><p><strong>PDFIXX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert 2 real*8 values from ‘xmm1’ into 2 integer*4 values in the low
half of ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “cvttpd2dq” avx_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DFIXK</span></code></dt><dd><p>Real*8 to to integer*8 type conversion.</p>
<p><em>Attributes</em>: arth null kr cse
.CG “cvttsd2si” ‘q’ sse_avx asm_special*double* fst lat(9)</p>
<p><em>ld</em> vector fadd fmul fstore lat(10)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DFIXUK</span></code></dt><dd><p>Real*8 to unsigned integer*8 type conversion.  Implemented as a QJSR.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SNGL</span></code></dt><dd><p>Real*8 to real*4 type conversion.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “cvtsd2ss” avx_special</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PSNGL</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert 2 real*8 values from ‘arlnk’ into 2 real*4 values in the low
half of ‘xmm’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “cvtpd2ps” avx_special*vector* lat(10)</p>
</li>
<li><p><strong>PSNGLX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert 2 real*8 values from ‘xmm1’ into 2 real*4 values in the low
half of ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “cvtpd2ps” avx_special*vector* lat(8)</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DBLE</span></code></dt><dd><p>Real*4 to real*8 type conversion.</p>
<p><em>Attributes</em>: arth null dp cse
.CG “cvtss2sd” avx_special</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PDBLE</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Convert ‘N’ packed real*4 values from ‘arlnk’ into ‘N’ packed real*8
values in ‘xmm’, where ‘N’ is 2, 4 or 8 if ‘xmm’ is an xmm (&gt;= SSE2),
ymm (&gt;= AVX) or zmm (AVX-512F) register respectively.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “cvtps2pd” ssedp sse_avx*double* lat(5)</p>
</li>
<li><p><strong>PDBLEX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Convert ‘N’ packed real*4 values from ‘xmm1’ (an xmm or ymm register)
into ‘N’ packed real*8 values in ‘xmm2’ (an xmm, ymm or zmm register),
where ‘N’ is 2, 4 or 8 if ‘xmm’ is an xmm (&gt;= SSE2), ymm (&gt;= AVX) or
zmm (AVX-512F) register respectively.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “cvtps2pd” ssedp avx_special*double* lat(3)</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">IR2SP</span></code></dt><dd><p>Copy an integer*4 value from a ‘gp’ register to an ‘xmm’ register without
type conversion.  The upper 12 bytes of the ‘xmm’ register are zeroed.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “movd” ‘l’ sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KR2SP</span></code></dt><dd><p>To be eliminated?</p>
<p><em>Attributes</em>: arth null sp
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KR2DP</span></code></dt><dd><p>Copy an integer*8 value from a ‘gp’ register to an ‘xmm’ register without
type conversion.  The upper 8 bytes of the ‘xmm’ register are zeroed.</p>
<p><em>Attributes</em>: arth null dp
.CG ‘q’ sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KR2CS</span></code></dt><dd><p>Copy an integer*8 value from a ‘gp’ register to an ‘xmm’ register without
type conversion.  The upper 8 bytes of the ‘xmm’ register are zeroed.</p>
<p><em>Attributes</em>: arth null cs
.CG ‘q’ sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SP2IR</span></code></dt><dd><p>Copy a real*4 value from an ‘xmm’ register to a ‘gp’ register without
type conversion.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “movd” ‘l’ sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SP2KR</span></code></dt><dd><p>Not used.</p>
<p><em>Attributes</em>: arth null kr
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP2KR</span></code></dt><dd><p>Copy a real*8 value from an ‘xmm’ register to a ‘gp’ register without
type conversion.</p>
<p><em>Attributes</em>: arth null kr
.CG ‘q’ sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CS2KR</span></code></dt><dd><p>Copy a single precision complex from an ‘xmm’ register to a ‘gp’ register
without type conversion.</p>
<p><em>Attributes</em>: arth null kr
.CG ‘q’ sse_avx asm_special</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ROTL</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p><em>Attributes</em>: arth null ir cse
.CG ccarith “rol” ‘l’</p>
</li>
<li><p><strong>ROTR</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p><em>Attributes</em>: arth null ir cse
.CG ccarith “ror” ‘l’</p>
</li>
<li><p><strong>IADD</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Signed integer addition.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG memdest ccarith “add” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>UIADD</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer addition.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG memdest ccarith “add” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>KADD</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Signed integer64 addition.</p>
<p><em>Attributes</em>: arth comm kr cse
.CG memdest ccarith “add” ‘q’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>UKADD</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Unsigned integer64 addition.</p>
<p><em>Attributes</em>: arth comm kr cse
.CG notCG replaceby KADD</p>
</li>
<li><p><strong>AADD</strong> arlnk stc    <em>Type</em>: <em>arlnk</em></p>
<p>Address unit add.
The stc operand is not used by the x86-64 code generator.</p>
<p><em>Attributes</em>: arth null ar cse
.CG notCG replaceby KADD</p>
</li>
<li><p><strong>FADD</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single-precision floating-point addition.</p>
<p><em>Attributes</em>: arth comm sp cse
.CG “addss” sse_avx*fadd* double lat(6:4)</p>
</li>
<li><p><strong>DADD</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double-precision floating-point addition.</p>
<p><em>Attributes</em>: arth comm dp cse
.CG “addsd” sse_avx*fadd* direct lat(6:4)</p>
</li>
<li><p><strong>SCMPLXADD</strong> cslnk    <em>Type</em>: <em>cslnk</em></p>
<p>Single-precision complex addition.</p>
<p><em>Attributes</em>: arth comm cs cse
.CG “addps” sse_avx*double* fadd lat(5:7)</p>
</li>
<li><p><strong>DCMPLXADD</strong> cdlnk    <em>Type</em>: <em>cdlnk</em></p>
<p>Double-precision complex addition.</p>
<p><em>Attributes</em>: arth comm cd cse
.CG “addpd” sse_avx*double* fadd lat(5:7)</p>
</li>
<li><p><strong>ISUB</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Signed 32-bit integer subtraction.</p>
<p><em>Attributes</em>: arth null ir cse
.CG memdest ccarith “sub” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>UISUB</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer subtract.  op1 - op2.</p>
<p><em>Attributes</em>: arth null ir cse
.CG memdest ccarith “sub” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>KSUB</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Signed integer64 subtraction.</p>
<p><em>Attributes</em>: arth null kr cse
.CG memdest ccarith “sub” ‘q’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>UKSUB</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Unsigned integer64 subtraction.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG replaceby KSUB</p>
</li>
<li><p><strong>ASUB</strong> arlnk stc    <em>Type</em>: <em>arlnk</em></p>
<p>Address unit subtract.
The stc operand is not used.</p>
<p><em>Attributes</em>: arth null ar cse
.CG notCG replaceby KSUB</p>
</li>
<li><p><strong>FSUB</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single-precision floating-point subtraction.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “subss” sse_avx*direct* fadd lat(6:4)</p>
</li>
<li><p><strong>FSUBR</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single-precision floating-point subtraction - operands reversed
(used by llvect.c as a convenience).</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>DSUB</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double-precision floating-point subtraction.</p>
<p><em>Attributes</em>: arth null dp cse
.CG “subsd” sse_avx*direct* fadd lat(6:4)</p>
</li>
<li><p><strong>SCMPLXSUB</strong> cslnk    <em>Type</em>: <em>cslnk</em></p>
<p>Single-precision complex subtraction.</p>
<p><em>Attributes</em>: arth null cs cse
.CG “subps” sse_avx*double* fadd lat(7:5)</p>
</li>
<li><p><strong>DCMPLXSUB</strong> cdlnk    <em>Type</em>: <em>cdlnk</em></p>
<p>Double-precision complex subtraction.</p>
<p><em>Attributes</em>: arth null cd cse
.CG “subpd” sse_avx*double* fadd lat(7:5)</p>
</li>
<li><p><strong>IMUL</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Integer Multiply.  It’a a bug to give this opcode the ‘cc’ attribute.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG “imul” ‘l’ ccmod*direct* lat(7)</p>
</li>
<li><p><strong>UIMUL</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer multiply. Same as signed.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG notCG replaceby IMUL</p>
</li>
<li><p><strong>IMULH</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Integer multiply, high 32-bits of product as result</p>
<p><em>Attributes</em>: arth comm ir cse
.CG “imul” ‘l’ ccmod*direct* lat(7)</p>
</li>
<li><p><strong>UIMULH</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Integer multiply, high 32-bits of product as result</p>
<p><em>Attributes</em>: arth comm ir cse
.CG “mul” ‘l’ ccmod*direct* lat(7)</p>
</li>
<li><p><strong>KMUL</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 Multiply.</p>
<p><em>Attributes</em>: arth comm kr cse
.CG “imul” ‘q’ ccmod*direct* lat(8)</p>
</li>
<li><p><strong>KMULH</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 Multiply, high 64-bits of product returned.</p>
<p><em>Attributes</em>: other comm kr cse
.CG “imul” ‘q’ ccmod*direct* lat(8)</p>
</li>
<li><p><strong>UKMUL</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Unsigned integer64 Multiply.</p>
<p><em>Attributes</em>: arth comm kr cse
.CG notCG replaceby KMUL</p>
</li>
<li><p><strong>UKMULH</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 Multiply, high 64-bits of product returned.</p>
<p><em>Attributes</em>: other comm kr cse
.CG “mul” ‘q’ ccmod*direct* lat(8)</p>
</li>
<li><p><strong>FMUL</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single-precision floating-point multiply.</p>
<p><em>Attributes</em>: arth comm sp cse
.CG “mulss” sse_avx*direct* fmul lat(4)</p>
</li>
<li><p><strong>DMUL</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double-precision multiply.</p>
<p><em>Attributes</em>: arth comm dp cse
.CG “mulsd” sse_avx*direct* fmul lat(6:4)</p>
</li>
<li><p><strong>SCMPLXMUL</strong> cslnk    <em>Type</em>: <em>cslnk</em></p>
<p>Single-complex multiply.</p>
<p><em>Attributes</em>: arth comm cs cse
.CG sse_avx asm_special</p>
</li>
<li><p><strong>DCMPLXMUL</strong> cdlnk    <em>Type</em>: <em>cdlnk</em></p>
<p>Double-complex multiply.</p>
<p><em>Attributes</em>: arth comm cd cse
.CG sse_avx asm_special</p>
</li>
<li><p><strong>IDIV</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Signed integer divide.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>UIDIV</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer divide.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>KDIV</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Signed integer64 divide.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</li>
<li><p><strong>UKDIV</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Unsigned integer64 divide.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</li>
<li><p><strong>IDIVZ</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Signed integer divide where divide by zero does not fault.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>UIDIVZ</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer divide where divide by zero does not fault.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>KDIVZ</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Signed integer64 divide where divide by zero does not fault.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</li>
<li><p><strong>UKDIVZ</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Unsigned integer64 divide where divide by zero does not fault.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</li>
<li><p><strong>IDIVZR</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Signed integer divide where the remainder is zero</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>KDIVZR</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Signed integer64 divide where the remainder is zero</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</li>
<li><p><strong>QUOREM</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Represents an integer divide and/or mod operation.  Use of this ili allows
a single divide instruction to both a divide and mod result.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notAILI ‘l’</p>
</li>
<li><p><strong>KQUOREM</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Represents a long divide and/or mod operation.  Use of this ili allows
a single divide instruction to both a divide and mod result.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notAILI ‘q’</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">NIDIV</span></code></dt><dd><p>Signed integer divide that points to QUOREM.  Result is in register %eax.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “idiv” ‘l’ ccmod</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NUIDIV</span></code></dt><dd><p>Unsigned integer divide that points to QUOREM.  Result is in register %eax.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “div” ‘l’ ccmod</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NKDIV</span></code></dt><dd><p>Signed integer64 divide that points to QUOREM.  Result is in register %rax.</p>
<p><em>Attributes</em>: arth null kr cse
.CG “idiv” ‘q’ ccmod</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NUKDIV</span></code></dt><dd><p>Unsigned integer64 divide that points to QUOREM.  Result is in register %rax.</p>
<p><em>Attributes</em>: arth null kr cse
.CG “div” ‘q’ ccmod</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>FDIV</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single-precision divide.</p>
<p><em>Attributes</em>: arth null sp cse
.CG “divss” sse_avx*direct* fmul lat(18:16)</p>
</li>
<li><p><strong>FDIVR</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single-precision divide - operands reversed (used by llvect.c
as a convenience).</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>DDIV</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double divide.</p>
<p><em>Attributes</em>: arth null dp cse
.CG “divsd” sse_avx*direct* fmul lat(22:20)</p>
</li>
<li><p><strong>SCMPLXDIV</strong> cslnk    <em>Type</em>: <em>cslnk</em></p>
<p>Single precision complex divide.</p>
<p><em>Attributes</em>: arth null cs cse
.CG “divps” sse_avx</p>
</li>
<li><p><strong>DCMPLXDIV</strong> cdlnk    <em>Type</em>: <em>cdlnk</em></p>
<p>Double precision complex divide.</p>
<p><em>Attributes</em>: arth null cd cse
.CG “divpd” sse_avx</p>
</li>
<li><p><strong>MOD</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Integer remainder.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>UIMOD</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer mod.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>KMOD</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 remainder.</p>
<p><em>Attributes</em>: arth null kr
.CG notCG</p>
</li>
<li><p><strong>KUMOD</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 remainder.</p>
<p><em>Attributes</em>: arth null kr
.CG notCG</p>
</li>
<li><p><strong>MODZ</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Integer remainder where divide by zero does not fault.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>UIMODZ</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer mod where divide by zero does not fault.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>KMODZ</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 remainder where divide by zero does not fault.</p>
<p><em>Attributes</em>: arth null kr
.CG notCG</p>
</li>
<li><p><strong>KUMODZ</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 remainder where divide by zero does not fault.</p>
<p><em>Attributes</em>: arth null kr
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">NMOD</span></code></dt><dd><p>Integer remainder that points to a QUOREM ili.  Result is in register %edx.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “idiv” ‘l’ ccmod</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NUIMOD</span></code></dt><dd><p>Unsigned integer mod that points to QUOREM ili.  Result is in register %edx.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “div” ‘l’ ccmod</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NKMOD</span></code></dt><dd><p>Integer remainder that points to a QUOREM ili.  Result is in register %rdx.</p>
<p><em>Attributes</em>: arth null kr cse
.CG “idiv” ‘q’ ccmod</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NUKMOD</span></code></dt><dd><p>Unsigned integer mod that points to QUOREM ili.  Result is in register %rdx.</p>
<p><em>Attributes</em>: arth null kr cse
.CG “div” ‘q’ ccmod</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>FMOD</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single-precision mod.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>DMOD</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double-precision mod.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</li>
<li><p><strong>IMAX</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Integer maximum value.  Expanded in-line by Code Generator.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG asm_special “cmpl” ‘l’ ccmod</p>
</li>
<li><p><strong>UIMAX</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer maximum value.  Expanded in-line by Code Generator.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG notCG</p>
</li>
<li><p><strong>IMIN</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Integer minimum value.  Expanded in-line by Code Generator.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG asm_special “cmpl” ‘l’ ccmod</p>
</li>
<li><p><strong>UIMIN</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer minimum value.  Expanded in-line by Code Generator.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG notCG</p>
</li>
<li><p><strong>KMAX</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 maximum value.  Expanded in-line by Code Generator.</p>
<p><em>Attributes</em>: arth comm kr cse
.CG asm_special “cmpq” ‘q’ ccmod</p>
</li>
<li><p><strong>UKMAX</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Unsigned integer64 maximum value.  Expanded in-line by Code Generator.</p>
<p><em>Attributes</em>: arth comm kr cse
.CG notCG</p>
</li>
<li><p><strong>KMIN</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 minimum value.  Expanded in-line by Code Generator.</p>
<p><em>Attributes</em>: arth comm kr cse
.CG asm_special “cmpq” ‘q’ ccmod</p>
</li>
<li><p><strong>UKMIN</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Unsigned integer64 minimum value.  Expanded in-line by Code Generator.</p>
<p><em>Attributes</em>: arth comm kr cse
.CG notCG</p>
</li>
<li><p><strong>FMAX</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single precision maximum.</p>
<p><em>Attributes</em>: arth comm sp cse
.CG “maxss” sse_avx*direct* fadd lat(4:2)</p>
</li>
<li><p><strong>FMIN</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Single precision minimum.</p>
<p><em>Attributes</em>: arth comm sp cse
.CG “minss” sse_avx*direct* fadd lat(4:2)</p>
</li>
<li><p><strong>DMAX</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double precision maximum.</p>
<p><em>Attributes</em>: arth comm dp cse
.CG “maxsd” sse_avx*direct* fadd lat(4:2)</p>
</li>
<li><p><strong>DMIN</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double precison minimum.</p>
<p><em>Attributes</em>: arth comm dp cse
.CG “minsd” sse_avx*direct* fadd lat(4:2)</p>
</li>
<li><p><strong>JN</strong> splnk    <em>Type</em>: <em>irlnk</em></p>
<p>float bessel_jn</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>DJN</strong> dplnk    <em>Type</em>: <em>irlnk</em></p>
<p>double bessel_jn</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</li>
<li><p><strong>YN</strong> splnk    <em>Type</em>: <em>irlnk</em></p>
<p>float bessel_yn</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>DYN</strong> dplnk    <em>Type</em>: <em>irlnk</em></p>
<p>double bessel_yn</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</li>
<li><p><strong>DFMA</strong> dplnk dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>This opcode is only used in AILIs, not shared or linear ILIs.  It
represents a scalar double-precision FMA3 or FMA4 instruction which
computes:</p>
<blockquote>
<div><p>dest = &lt;sign&gt; (src1 * src2) &lt;addop&gt; src3</p>
</div></blockquote>
<p>Either ‘src2’ or ‘src3’, but not both, can be a memory operand, and
the other operands are xmm register operands.  The values of &lt;sign&gt;
(+/-) and &lt;addop&gt; (+/-) are specified by an ‘FMA_…’ flag set in the
cc field of the AILI.  Since AILIs allow at most 2 source operands,
this AILI is always immediately preceded by a USE AILI which specifies
the ‘src1’ operand.</p>
<p><em>Attributes</em>: arth null dp
.CG CGonly asm_special</p>
</li>
<li><p><strong>FFMA</strong> splnk splnk    <em>Type</em>: <em>splnk</em></p>
<p>This is the same as DFMA except that it represents a scalar single
precision FMA3 or FMA4 instruction.</p>
<p><em>Attributes</em>: arth null sp
.CG CGonly asm_special</p>
</li>
<li><p><strong>IPOWI</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Integer raised to an integer power.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>KPOWI</strong> irlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer raised to an integer power.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</li>
<li><p><strong>KPOWK</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Integer raised to an integer power.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</li>
<li><p><strong>FPOWI</strong> irlnk    <em>Type</em>: <em>splnk</em></p>
<p>Real raised to an integer power.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>FPOWK</strong> krlnk    <em>Type</em>: <em>splnk</em></p>
<p>Real raised to an integer power.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>FPOWF</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Real raised to a real power.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</li>
<li><p><strong>DPOWI</strong> irlnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double raised to a integer power.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</li>
<li><p><strong>DPOWK</strong> krlnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double raised to a integer power.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</li>
<li><p><strong>DPOWD</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Double raised to a double power.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</li>
<li><p><strong>ICMP</strong> irlnk stc    <em>Type</em>: <em>irlnk</em></p>
<p>Integer compare with result of true or false.
For C the value of true is 1, and for Fortran, -1.
'stc’ denotes condition code, as for the ICJMP ili.
Due to problems when this operation is used with SELECT ili, it is
not given the ‘cse’ attribute.</p>
<p><em>Attributes</em>: arth null ir cse
.CG asm_special “cmpl” ‘l’ ccmod*direct* lat(4:1)</p>
</li>
<li><p><strong>UICMP</strong> irlnk stc    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer compare.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notAILI ‘l’</p>
</li>
<li><p><strong>KCMP</strong> krlnk stc    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 compare with result of true or false.
Conditions are same as ICJMP ILI.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notAILI “cmpq” ‘q’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>UKCMP</strong> krlnk stc    <em>Type</em>: <em>krlnk</em></p>
<p>Integer compare with result of true or false.
Conditions are same as ICJMP ILI.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notAILI ‘q’</p>
</li>
<li><p><strong>ACMP</strong> arlnk stc    <em>Type</em>: <em>arlnk</em></p>
<p>Address compare with result of true or false.
The conditions (stc) are the same as for ICMP.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG replaceby UKCMP</p>
</li>
<li><p><strong>FCMP</strong> splnk stc    <em>Type</em>: <em>splnk</em></p>
<p>Single float compare with result of true or false.</p>
<p><em>Attributes</em>: arth null ir cse
.CG asm_special “ucomiss” ccmod sse_avx*vector* lat(6:4)</p>
</li>
<li><p><strong>DCMP</strong> dplnk stc    <em>Type</em>: <em>dplnk</em></p>
<p>Double precision compare with result of true or false.</p>
<p><em>Attributes</em>: arth null ir cse
.CG asm_special “ucomisd” ccmod sse_avx*vector* fadd lat(5:4)</p>
</li>
<li><p><strong>SCMPLXCMP</strong> dplnk stc    <em>Type</em>: <em>dplnk</em></p>
<p>Single precision complex compare with result of true or false.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG asm_special “ucomisd” ccmod sse_avx*vector* fadd lat(5:4)</p>
</li>
<li><p><strong>DCMPLXCMP</strong> dplnk stc    <em>Type</em>: <em>dplnk</em></p>
<p>Double precision complex compare with result of true or false.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG asm_special “ucomisd” ccmod sse_avx*vector* fadd lat(5:4)</p>
</li>
<li><p><strong>ICMPZ</strong> stc    <em>Type</em>: <em>irlnk</em></p>
<p>Integer compare with zero.
Conditions are same as ICJMP ILI.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notAILI ‘l’</p>
</li>
<li><p><strong>UICMPZ</strong> stc    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer compare with zero.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notAILI ‘l’</p>
</li>
<li><p><strong>KCMPZ</strong> stc    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 compare with zero; returns integer value.
Conditions are same as ICJMP ILI.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notAILI ‘q’</p>
</li>
<li><p><strong>UKCMPZ</strong> stc    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 compare with zero.
Conditions are same as ICJMP ILI.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notAILI ‘q’</p>
</li>
<li><p><strong>ACMPZ</strong> stc    <em>Type</em>: <em>arlnk</em></p>
<p>Address compare with zero.
The conditions (stc) are the same as for ICMP.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG replaceby UKCMPZ</p>
</li>
<li><p><strong>FCMPZ</strong> stc    <em>Type</em>: <em>splnk</em></p>
<p>Single float compare with zero; result is TRUE or FALSE.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>DCMPZ</strong> stc    <em>Type</em>: <em>dplnk</em></p>
<p>Double precision compare with zero.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>QCMPZ</strong> stc    <em>Type</em>: <em>qplnk</em></p>
<p>Quad precision compare with zero.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>TEST</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Compare register value with 0.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG CGonly “testl” cclogical ‘l’ asm_special*direct* lat(4:1)</p>
</li>
<li><p><strong>KTEST</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Compare register value with 0.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG CGonly “testq” cclogical ‘q’ asm_special*direct* lat(4:1)</p>
</li>
<li><p><strong>ISELECT</strong> irlnk irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Select either the 2nd or 3rd operand value based on the comparison
operation pointed to by the 1st operand.</p>
<p><em>Attributes</em>: other null ir cse
.CG notAILI ‘l’</p>
</li>
<li><p><strong>KSELECT</strong> krlnk krlnk    <em>Type</em>: <em>irlnk</em></p>
<p><em>Attributes</em>: other null kr cse
.CG notAILI ‘q’</p>
</li>
<li><p><strong>ASELECT</strong> arlnk arlnk    <em>Type</em>: <em>irlnk</em></p>
<p><em>Attributes</em>: other null ar cse
.CG notCG replaceby KSELECT</p>
</li>
<li><p><strong>FSELECT</strong> splnk splnk    <em>Type</em>: <em>irlnk</em></p>
<p><em>Attributes</em>: other null sp cse
.CG notAILI</p>
</li>
<li><p><strong>DSELECT</strong> dplnk dplnk    <em>Type</em>: <em>irlnk</em></p>
<p><em>Attributes</em>: other null dp cse
.CG notAILI</p>
</li>
<li><p><strong>CSSELECT</strong> cslnk cslnk    <em>Type</em>: <em>irlnk</em></p>
<p><em>Attributes</em>: other null cs cse
.CG notAILI</p>
</li>
<li><p><strong>CDSELECT</strong> cdlnk cdlnk    <em>Type</em>: <em>irlnk</em></p>
<p><em>Attributes</em>: other null cd cse
.CG notAILI</p>
</li>
<li><p><strong>AND</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Bitwise 32-bit ‘and’ operation.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG memdest cclogical “and” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>KAND</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Bitwise 64-bit ‘and’ operation.</p>
<p><em>Attributes</em>: arth comm kr
.CG memdest cclogical “and” ‘q’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>OR</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Bitwise 32-bit ‘or’ operation.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG memdest cclogical “or” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>KOR</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Bitwise 64-bit ‘or’ operation.</p>
<p><em>Attributes</em>: arth comm kr
.CG memdest cclogical “or” ‘q’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>XOR</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Bitwise exclusive-or operation.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG memdest cclogical “xor” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>LEQV</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Bitwise exclusive-or followed by not operation.</p>
<p><em>Attributes</em>: arth comm ir cse
.CG memdest cclogical “notxor” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>KXOR</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Bitwise 64-bit exclusive-or operation.</p>
<p><em>Attributes</em>: arth comm kr
.CG memdest cclogical “xor” ‘q’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>EQV</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p><em>Attributes</em>: arth comm ir cse
.CG notCG</p>
</li>
<li><p><strong>JISHFT</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Shift op1 by op2.  Left if op2 is &gt; 0; else right (no sign extension).
This ili only shows up for Fortran, specifically for the JISHFT intrinsic.
If 2nd operand is compile time constant, this ili will have been
replaced by either a left or right shift ili by the Expander.
Otherwise, it is implemented as a call to a run-time function.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>KISHFT</strong> krlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Shift op1 by op2.  Left if op2 is &gt; 0; else right (no sign extension).
This ili only shows up for Fortran, specifically for the KISHFT intrinsic.
If 2nd operand is compile time constant, this ili will have been
replaced by either a left or right shift ili by the Expander.
Otherwise, it is implemented as a call to a run-time function.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</li>
<li><p><strong>USHIFT</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Shift op1 logically by op2.  Left if op2 is &gt; 0; else right.
This ili should have been replaced before code generator.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>SHIFTA</strong> arlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Shift op1 logically by op2.  Left if op2 is &gt; 0; else right.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>USHIFTA</strong> arlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned shift op1 logically by op2.  Left if op2 is &gt; 0; else right.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>LSHIFT</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Shift op1 left logically by op2.</p>
<p><em>Attributes</em>: arth null ir cse
.CG memdest ccarith shiftop asm_special “shl” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>ULSHIFT</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Shift op1 left logically by op2.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG replaceby LSHIFT</p>
</li>
<li><p><strong>LSHIFTI</strong> stc    <em>Type</em>: <em>irlnk</em></p>
<p>Shift left immediate.   This opcode used only in Code Generator.</p>
<p><em>Attributes</em>: arth null ir cse
.CG memdest ccarith shiftop “shl” CGonly ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>KLSHIFTI</strong> stc    <em>Type</em>: <em>krlnk</em></p>
<p>Shift left immediate of 64-bit value.</p>
<p><em>Attributes</em>: arth null kr cse
.CG memdest ccarith shiftop “shl” CGonly ‘q’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>RSHIFT</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Shift op1 logically right by op2 (sign extended).</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG replaceby ARSHIFT</p>
</li>
<li><p><strong>URSHIFT</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Shift op1 logically right by op2 (0 fill).</p>
<p><em>Attributes</em>: arth null ir cse
.CG memdest ccarith shiftop asm_special “shr” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>ARSHIFT</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>Shift op1 arithmetically (sign extended) right by op2.
Used for right shifts (&gt;&gt; operator) of signed values.</p>
<p><em>Attributes</em>: arth null ir cse
.CG memdest ccarith shiftop asm_special “sar” ‘l’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>KLSHIFT</strong> irlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Left shift of 64-bit value.</p>
<p><em>Attributes</em>: arth null kr cse
.CG memdest ccarith shiftop asm_special “shl” ‘q’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>KURSHIFT</strong> irlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Zero-fill right shift of 64-bit value.</p>
<p><em>Attributes</em>: arth null kr cse
.CG memdest ccarith shiftop asm_special “shr” ‘q’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>KARSHIFT</strong> irlnk    <em>Type</em>: <em>krlnk</em></p>
<p>Sign-extended right shift of 64-bit value.</p>
<p><em>Attributes</em>: arth null kr cse
.CG memdest ccarith shiftop asm_special “sar” ‘q’<em>direct</em> lat(4:1)</p>
</li>
<li><p><strong>ILEADZI</strong> stc    <em>Type</em>: <em>irlnk</em></p>
<p>8-/16- bit integer LEADZ intrinsic.
The value, 0 or 1, of the second operand indicates
8-bit or 16-bit, respectively.</p>
<p><em>Attributes</em>: arth null ir cse</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ILEADZ</span></code></dt><dd><p>32-bit integer LEADZ intrinsic.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “lzcnt” ‘l’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KLEADZ</span></code></dt><dd><p>64-bit integer LEADZ intrinsic.</p>
<p><em>Attributes</em>: arth null kr cse
.CG “lzcnt” ‘q’</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ITRAILZI</strong> stc    <em>Type</em>: <em>irlnk</em></p>
<p>8-/16- bit integer TRAILZ intrinsic.
The value, 0 or 1, of the second operand indicates
8-bit or 16-bit, respectively.</p>
<p><em>Attributes</em>: arth null ir cse</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ITRAILZ</span></code></dt><dd><p>32-bit integer TRAILZ intrinsic.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “tzcnt” ‘l’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KTRAILZ</span></code></dt><dd><p>64-bit integer TRAILZ intrinsic.</p>
<p><em>Attributes</em>: arth null kr cse
.CG “tzcnt” ‘q’</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>IPOPCNTI</strong> stc    <em>Type</em>: <em>irlnk</em></p>
<p>8-/16- bit integer POPCNT intrinsic.
The value of second operand indicates 8-bit if 0 and 16-bit
if 1.</p>
<p><em>Attributes</em>: arth null ir cse</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">IPOPCNT</span></code></dt><dd><p>32-bit integer POPCNT intrinsic.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “popcnt” ‘l’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KPOPCNT</span></code></dt><dd><p>64-bit integer POPCNT intrinsic.</p>
<p><em>Attributes</em>: arth null kr cse
.CG “popcnt” ‘q’</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>IPOPPARI</strong> stc    <em>Type</em>: <em>irlnk</em></p>
<p>8-/16- bit integer POPPAR intrinsic.
The value of second operand indicates 8-bit if 0 and 16-bit
if 1.</p>
<p><em>Attributes</em>: arth null ir cse</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">IPOPPAR</span></code></dt><dd><p>32-bit integer POPPAR intrinsic.</p>
<p><em>Attributes</em>: arth null ir cse</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KPOPPAR</span></code></dt><dd><p>64-bit integer POPPAR intrinsic.</p>
<p><em>Attributes</em>: arth null kr cse</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>EXTRACT</strong> stc stc    <em>Type</em>: <em>irlnk</em></p>
<p>Note that this ILI is defined for machines with bit field extract
HW support (e.g. 88000).
The two stc operand definitions are architecture DEPENDENT.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">JMP</span></code></dt><dd><p>Unconditional jump to indicated label.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal “jmp”<em>direct</em> lat(4:1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">JMPA</span></code></dt><dd><p>Branch indirect.  Fortran only.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal “jmp” asm_special*direct* lat(4:1)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>JMPM</strong> irlnk sym sym    <em>Type</em>: <em>irlnk</em></p>
<p>Indexed jump from a memory table of jump addresses.
irlnk1 - integer index expression.</p>
<p>irlnk2 - table_size</p>
<p>sym - label for memory table containing addresses</p>
<p>sym  - default label</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal asm_special ‘l’</p>
</li>
<li><p><strong>JMPMK</strong> irlnk sym sym    <em>Type</em>: <em>krlnk</em></p>
<p>Indexed jump using a 64-bit integer as index value.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal notAILI ‘q’</p>
</li>
<li><p><strong>JMPT</strong> irlnk    <em>Type</em>: <em>irlnk</em></p>
<p>NOT USED.
Indexed jump into a table of jump instructions.</p>
<div class="line-block">
<div class="line">irlnk1 - integer index expression. The expression has</div>
<div class="line-block">
<div class="line">already been normalized to 1 (the value 0 is</div>
<div class="line">reserved for the “default” jump). If the expression</div>
<div class="line">is not in the range 1:(n-1) where n is the jump table</div>
<div class="line">size, the default jump is taken.</div>
</div>
<div class="line">irlnk2 - table_size (includes the default label).</div>
</div>
<p><em>Attributes</em>: branch null trm dom
.CG notCG</p>
</li>
<li><p><strong>QSWITCH</strong> lnk stc    <em>Type</em>: <em>sym</em></p>
<p><em>Attributes</em>: proc null lnk dom
.CG notCG</p>
</li>
<li><p><strong>ICJMP</strong> irlnk stc sym    <em>Type</em>: <em>irlnk</em></p>
<p>Integer compare and jump to the label ‘sym’
if the condition, denoted by stc, is true.
Allowed values of stc:</p>
<blockquote>
<div><p>1 = CC_EQ   (jump if equal)
2 = CC_NE   (jump if not equal)
3 = CC_LT   (jump if less than)
4 = CC_GE   (jump if greater than or equal to)
5 = CC_LE   (jump if less than or equal to)
6 = CC_GT   (jump if greater than)</p>
</div></blockquote>
<p><em>Attributes</em>: branch null trm dom
.CG terminal notAILI ‘l’ conditional_branch</p>
</li>
<li><p><strong>UICJMP</strong> irlnk stc sym    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer compare and jump to the label ‘sym’
if the condition, denoted by stc, is true.
Conditions same as for ICJMP.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal notAILI ‘l’ conditional_branch</p>
</li>
<li><p><strong>KCJMP</strong> krlnk stc sym    <em>Type</em>: <em>krlnk</em></p>
<p>integer64 compare and jump to the label ‘sym’
if the condition, denoted by stc, is true:
The same conditions as ICJMP</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal notAILI ‘q’ conditional_branch</p>
</li>
<li><p><strong>UKCJMP</strong> krlnk stc sym    <em>Type</em>: <em>krlnk</em></p>
<p>unsigned integer64 compare and jump to the label ‘sym’
if the condition, denoted by stc, is true:
The same conditions as ICJMP</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal notAILI ‘q’ conditional_branch</p>
</li>
<li><p><strong>ACJMP</strong> arlnk stc sym    <em>Type</em>: <em>arlnk</em></p>
<p>Address compare and jump to the label ‘sym’
if the condition, denoted by stc, is true:
Conditions same as for ICJMP.</p>
<p><em>Attributes</em>: branch null trm dom
.CG notCG replaceby UKCJMP conditional_branch</p>
</li>
<li><p><strong>FCJMP</strong> splnk stc sym    <em>Type</em>: <em>splnk</em></p>
<p>Single precision compare and jump to the label ‘sym’
if the condition, denoted by stc, is true.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal conditional_branch notAILI</p>
</li>
<li><p><strong>DCJMP</strong> dplnk stc sym    <em>Type</em>: <em>dplnk</em></p>
<p>Double precision compare and jump to the label ‘sym’
if the condition, denoted by stc, is true.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal conditional_branch notAILI</p>
</li>
<li><p><strong>QCJMP</strong> qplnk stc sym    <em>Type</em>: <em>qplnk</em></p>
<p>Quad precision compare and jump to the label ‘sym’
if the condition, denoted by stc, is true.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal conditional_branch notAILI</p>
</li>
<li><p><strong>ICJMPZ</strong> stc sym    <em>Type</em>: <em>irlnk</em></p>
<p>Integer compare with zero and branch to label ‘sym’ -
the allowed values (and meanings) for stc are the same as
for the ICJMP ILI.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal notAILI ‘l’ conditional_branch</p>
</li>
<li><p><strong>UICJMPZ</strong> stc sym    <em>Type</em>: <em>irlnk</em></p>
<p>Unsigned integer compare with zero and branch to label ‘sym’ -
the allowed values (and meanings) for stc are the same as
for the ICJMP ILI.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal notAILI ‘l’ conditional_branch</p>
</li>
<li><p><strong>LCJMPZ</strong> stc sym    <em>Type</em>: <em>irlnk</em></p>
<p>Logical compare with zero and branch to label ‘sym’ -
the allowed values (and meanings) for stc are the same as
for the ICJMP ILI.</p>
<p><em>Attributes</em>: branch null trm dom
.CG notCG replaceby UICJMPZ conditional_branch</p>
</li>
<li><p><strong>KCJMPZ</strong> stc sym    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 compare with zero and branch to label ‘sym’ -
the allowed values (and meanings) for stc are the same as
for the ICJMP ILI.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal notAILI ‘q’ conditional_branch</p>
</li>
<li><p><strong>UKCJMPZ</strong> stc sym    <em>Type</em>: <em>krlnk</em></p>
<p>Integer64 compare with zero and branch to label ‘sym’ -
the allowed values (and meanings) for stc are the same as
for the ICJMP ILI.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal notAILI ‘q’ conditional_branch</p>
</li>
<li><p><strong>ACJMPZ</strong> stc sym    <em>Type</em>: <em>arlnk</em></p>
<p>Address compare with zero and branch to label ‘sym’ -
the allowed values (and meanings) for stc are the same as
for the ICJMP ILI.</p>
<p><em>Attributes</em>: branch null trm dom
.CG notCG replaceby UKCJMPZ conditional_branch</p>
</li>
<li><p><strong>FCJMPZ</strong> stc sym    <em>Type</em>: <em>splnk</em></p>
<p>Single compare with zero and branch to label ‘sym’.</p>
<p><em>Attributes</em>: branch null trm dom
.CG notCG conditional_branch</p>
</li>
<li><p><strong>DCJMPZ</strong> stc sym    <em>Type</em>: <em>dplnk</em></p>
<p>Double compare with zero and branch to label ‘sym’.</p>
<p><em>Attributes</em>: branch null trm dom
.CG notCG conditional_branch</p>
</li>
<li><p><strong>QCJMPZ</strong> stc sym    <em>Type</em>: <em>qplnk</em></p>
<p>quad compare with zero and branch to label ‘sym’.</p>
<p><em>Attributes</em>: branch null trm dom
.CG notCG conditional_branch</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">JCC</span></code></dt><dd><p>Conditional jump based on immediately preceding compare operation.
Used only in the AILI.</p>
<p><em>Attributes</em>: branch null trm dom
.CG CGonly asm_special conditional_branch*direct* lat(1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CSEIR</span></code></dt><dd><p>Integer register cse (common subexpression). The ILI located by the cse
ILI is one whose value is to be re-used (the ILI need not be “evaluated”).
This ILI is used when multiple references of an ILM occur in the same
ILM block.
The CSE ili are treated as a special case by the linearizer, and never
appear in a linear ili block.</p>
<p><em>Attributes</em>: arth null ir
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CSESP</span></code></dt><dd><p>Single precision register cse.</p>
<p><em>Attributes</em>: arth null sp
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CSEDP</span></code></dt><dd><p>Double precision register cse.</p>
<p><em>Attributes</em>: arth null dp
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CSEQP</span></code></dt><dd><p>Quad precision register cse.</p>
<p><em>Attributes</em>: arth null qp
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CSECS</span></code></dt><dd><p>Single precision complex register cse.</p>
<p><em>Attributes</em>: arth null cs
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CSECD</span></code></dt><dd><p>Double precision complex register cse.</p>
<p><em>Attributes</em>: arth null cd
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CSEAR</span></code></dt><dd><p>Address register cse.</p>
<p><em>Attributes</em>: arth null ar
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CSEKR</span></code></dt><dd><p>Integer64 register cse.</p>
<p><em>Attributes</em>: arth null kr
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>CSE</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>Complex cse (common subexpression). The ILI located by the cse
ILI is one whose value is to be re-used (the ILI need not be “evaluated”).
This ILI is used when multiple references of an ILM occur in the same
ILM block.
This ili is seen by the code generator but never appears in the
linear ili.</p>
<p><em>Attributes</em>: arth null ir
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">APURE</span></code></dt><dd><p>Call a pure function with no arguments and returns an AR value.
Will always have an ALT which is the actual call.
arlnk is an ACON ili of the function being called.</p>
<p><em>Attributes</em>: arth null ar cse
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>APUREA</strong> arlnk    <em>Type</em>: <em>arlnk</em></p>
<p>Call a pure function with one AR argument and returns an AR value.
Will always have an ALT which is the actual call.
arlnk is an ACON ili of the function being called.</p>
<p><em>Attributes</em>: arth null ar cse
.CG notCG</p>
</li>
<li><p><strong>APUREI</strong> irlnk    <em>Type</em>: <em>arlnk</em></p>
<p>Call a pure function with one IR argument and returns an AR value.
Will always have an ALT which is the actual call.
arlnk is an ACON ili of the function being called.</p>
<p><em>Attributes</em>: arth null ar cse
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">IPURE</span></code></dt><dd><p>Call a pure function with no arguments and returns an IR value.
Will always have an ALT which is the actual call.
arlnk is an ACON ili of the function being called.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>IPUREA</strong> arlnk    <em>Type</em>: <em>arlnk</em></p>
<p>Call a pure function with one AR argument and returns an IR value.
Will always have an ALT which is the actual call.
arlnk is an ACON ili of the function being called.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>IPUREI</strong> irlnk    <em>Type</em>: <em>arlnk</em></p>
<p>Call a pure function with one IR argument and returns an IR value.
Will always have an ALT which is the actual call.
arlnk is an ACON ili of the function being called.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">REP</span></code></dt><dd><p>Repeat prefix opcode for string operations (such as the following SMOVE).
Emitted immediately before an SMOVE operation.</p>
<p><em>Attributes</em>: other null trm dom
.CG CGonly “rep”</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>GSMOVE</strong> arlnk nme nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>General structure copy.
A structure store (SMOVE ILM) is expanded into the GSMOVE ILI; a phase, such as
the ACC CG, needs to have the structure assignment presented as a first-class
ILI operation.
After the last phase requiring GSMOVE, GSMOVE will then be expanded into
lower level ILI which will be dependent on target, alignment, small vs large,
etc.</p>
<blockquote>
<div><p>'op1’ is the source address.
'op2’ is the destination address.
'nme1’ is the names table entry for source struct.
'nme2’ is the names table entry for the destination struct.
'stc’ is the dtype of the struct.</p>
</div></blockquote>
<p><em>Attributes</em>: other null trm dom
.CG notCG</p>
</li>
<li><p><strong>SMOVE</strong> arlnk arlnk nme    <em>Type</em>: <em>arlnk</em></p>
<dl class="simple">
<dt>Structure copy.</dt><dd><p>'op1’ is the source address.
'op2’ is the destination address.
'op3’ is number of 8-byte units to copy.
'nme’ is names table entry for destination struct.</p>
</dd>
</dl>
<p><em>Attributes</em>: other null trm dom
.CG terminal “movs”</p>
</li>
<li><p><strong>SMOVEJ</strong> arlnk nme nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Simple structure copy.  (MOVS is x86 parlance.)
This is used to replace the SMOVEI/SMOVES pair, which was used when
the ILI operand count was only 4.
'op1’ is the source address
'op2’ is the destination address
'nme1’ is the names table entry for source struct.
'nme2’ is the names table entry for the destination struct.
'op5’ is actual number of bytes to copy.
This gets turned into SMOVE and load/store operations by rm_smove</p>
<p><em>Attributes</em>: other null trm dom
.CG notCG</p>
</li>
<li><p><strong>XMOVE</strong> arlnk nme    <em>Type</em>: <em>arlnk</em></p>
<dl class="simple">
<dt>Structure copy.</dt><dd><p>'op1’ is the source address.
'op2’ is the destination address.
'nme’ is names table entry for destination struct.</p>
</dd>
</dl>
<p><em>Attributes</em>: other null trm dom
.CG terminal “movapd” sse_avx</p>
</li>
<li><p><strong>ST</strong> arlnk nme stc    <em>Type</em>: <em>irlnk</em></p>
<p>Store integer value.
In ILI, the value to be stored must fit without implicit truncation, i.e. immediately
reloading using LD with the same size modifier must reproduce the value that was stored.
In LILI or AILI, ST may perform implicit truncation.
'op1’ is a pointer to an ili representing the value being stored.</p>
<p>'op2’ is a pointer to the address expression of the variable being defined.</p>
<p>'nme’ is a pointer to a names table entry of the variable being defined.</p>
<p>'stc’ is the size modifier of the memory operation as described for
the LD ili above.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “mov” move*direct* lat(1)</p>
<p><em>ld</em> direct lat(3)</p>
<p><em>st</em> direct lat(3)</p>
</li>
<li><p><strong>STSP</strong> arlnk nme stc    <em>Type</em>: <em>splnk</em></p>
<p>Store single precision quantity.  ‘stc’ must be MSZ_F4.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “movss” move avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</li>
<li><p><strong>STDP</strong> arlnk nme stc    <em>Type</em>: <em>dplnk</em></p>
<p>Store double precision quantity.  ‘stc’ must be MSZ_F8.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “movsd” move avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>STSCMPLX</strong> arlnk nme stc    <em>Type</em>: <em>cslnk</em></p>
<p>Store single precision complex quantity.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “movsd” move avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>STDCMPLX</strong> arlnk nme stc    <em>Type</em>: <em>cdlnk</em></p>
<p>Store double precision complex quantity.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “movupd” move sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>STQ</strong> arlnk nme stc    <em>Type</em>: <em>dplnk</em></p>
<p>Store an __m128 quantity.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “movapd” move sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>STQU</strong> arlnk nme stc    <em>Type</em>: <em>dplnk</em></p>
<p>Store an unaligned __m128 quantity.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “movupd” move sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>ST256</strong> arlnk nme stc    <em>Type</em>: <em>dplnk</em></p>
<p>Store an __m256 quantity.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “vmovapd” ‘y’ move avx_only*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>ST256U</strong> arlnk nme stc    <em>Type</em>: <em>dplnk</em></p>
<p>Store an unaligned __m256 quantity.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “vmovupd” ‘y’ move avx_only*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>ST512</strong> arlnk nme stc    <em>Type</em>: <em>512lnk</em></p>
<p>Store an __m512 value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “vmovupd” ‘z’ move avx_only*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>STA</strong> arlnk nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store address quantity inside of op1 into op2.
Replaced by ST opcode in cgoptim1.</p>
<p><em>Attributes</em>: store null trm
.CG terminal notAILI</p>
</li>
<li><p><strong>STRG1</strong> stc    <em>Type</em>: <em>arlnk</em></p>
<p>Store address quantity inside of op1 argument register described by stc.
Used in g++ style
thunks when adjusting the *this* pointer, (the first argument) just
before jumping through to the function Replaced by ST opcode in cgoptim1.</p>
<p><em>Attributes</em>: store null trm
.CG terminal notAILI</p>
</li>
<li><p><strong>STKR</strong> arlnk nme stc    <em>Type</em>: <em>krlnk</em></p>
<p>Store 64 bit integer value.  ‘stc’ should be MSZ_I8.
(There may be legacy cases needing repair where it is zero.)
Replaced by ST opcode with size == MSZ_I8 in cgoptim1.</p>
<p><em>Attributes</em>: store null trm
.CG terminal notAILI</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">VZST</span></code></dt><dd><p>Special ili created by the vectorizer indicating that the variable
whose address is op1 is stored; necessary in cases where
the vectorizer replaces assignments with calls.  The optimizer will process
the ili to create store information and then delete the ili.  Code generator
will not see this ili.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>JSR</strong> lnk    <em>Type</em>: <em>sym</em></p>
<p>'sym’ is external function or subroutine being called (standard linkage).
'lnk’ points to a list (terminated by NULL) of ARG ili for the
arguments.</p>
<p><em>Attributes</em>: proc null lnk dom
.CG terminal “call” asm_special ccmod</p>
</li>
<li><p><strong>JSRA</strong> lnk stc stc    <em>Type</em>: <em>arlnk</em></p>
<p>JSR to routine whose address is pointed to by arlnk.
lnk points to the list of ARG ILIs which represents the arguments.
stc1 attribute flag (stdcall in x86)
stc2 dtype</p>
<p><em>Attributes</em>: proc null lnk dom
.CG terminal notAILI</p>
</li>
<li><p><strong>QJSR</strong> lnk    <em>Type</em>: <em>sym</em></p>
<p>Quick (intrinsic) call.
'sym’ is the external procedure being called.
'lnk’ locates the list of arguments (define arg ILI - DAAR, DADR, DADP).</p>
<p><em>Attributes</em>: proc null lnk dom
.CG terminal “call” asm_special ccmod</p>
</li>
<li><p><strong>GJSR</strong> lnk sym    <em>Type</em>: <em>sym</em></p>
<p>Same as JSR, but the argument list is expressed using the general argument
ILI, i.e., before applying the ABI.
'sym2’ is the label to jump to if an exception is thrown,
0 if the call cannot throw,
or -1 if there is no cleanup.</p>
<p><em>Attributes</em>: proc null lnk dom
.CG terminal notCG</p>
</li>
<li><p><strong>GJSRA</strong> lnk stc stc sym    <em>Type</em>: <em>arlnk</em></p>
<p>Same as JSRA, but the argument list is expressed using the general argument
ILI, i.e., before applying the ABI.</p>
<p><em>Attributes</em>: proc null lnk dom
.CG terminal notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">NULL</span></code></dt><dd><p>Used to mark the end of an argument list for a JSR, QJSR or JSRA ili.</p>
<p><em>Attributes</em>: other null lnk
.CG notAILI</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>GARG</strong> lnk stc nme    <em>Type</em>: <em>lnk</em></p>
<p>A general argument link, used before applying the ABI
'lnk’ (first) points to the value of the argument.
'lnk’ (second) points to the next ARG ILI.
First 'stc’ is the dtype.
Second 'stc’ is an NME value, if set, for address arguments.</p>
<p><em>Attributes</em>: define null lnk
.CG notCG</p>
</li>
<li><p><strong>GARGRET</strong> lnk stc nme    <em>Type</em>: <em>lnk</em></p>
<p>A general argument link representing the return value of the function
'lnk’ (first) points to the value of the argument.
'lnk’ (second) points to the next ARG ILI.
'stc’ is the dtype
'nme’ is the nme</p>
<p><em>Attributes</em>: define null lnk
.CG notCG</p>
</li>
<li><p><strong>VA_ARG</strong> stc    <em>Type</em>: <em>arlnk</em></p>
<p>va_arg(va_list x, typeof_arg) computes the address of the argument
‘arlnk’ address of the va_list
‘stc’ the dtype of the argument being reference</p>
<p><em>Attributes</em>: arth null ar
.CG notCG</p>
</li>
<li><p><strong>ARGIR</strong> lnk    <em>Type</em>: <em>irlnk</em></p>
<p>Defines an integer memory argument.
'irlnk’ points to the register value of the argument.
'lnk’ points to the next ARG ILI.</p>
<p><em>Attributes</em>: define null lnk
.CG memarg “mov” ‘l’<em>direct</em> lat(1)</p>
<p><em>ld</em> direct lat(3)</p>
<p><em>st</em> direct lat(3)</p>
</li>
<li><p><strong>ARGSP</strong> lnk    <em>Type</em>: <em>splnk</em></p>
<p>Defines a single-precision memory argument.
'splnk’ points to the register value of the argument.
'lnk’ points to the next ARG ILI.</p>
<p><em>Attributes</em>: define null lnk
.CG memarg “movss” avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</li>
<li><p><strong>ARGDP</strong> lnk    <em>Type</em>: <em>dplnk</em></p>
<p>Defines a double precision memory argument.
'dplnk’ points to the register value of the argument.
'lnk’ points to the next ARG ILI.</p>
<p><em>Attributes</em>: define null lnk
.CG memarg “movsd” avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>ARGAR</strong> lnk stc    <em>Type</em>: <em>arlnk</em></p>
<p>A memory argument of type pointer or struct/union.
'arlnk’ points to the value of the argument.
'lnk’ points to the next ARG ILI.
'stc’ is the dtype if this is a struct arg, else it is 0.</p>
<p><em>Attributes</em>: define null lnk
.CG memarg “mov” ‘q’<em>ld</em> double fadd fmul fst lat(4)</p>
<p><em>st</em> double fst lat(4)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>ARGKR</strong> lnk    <em>Type</em>: <em>krlnk</em></p>
<p>Defines a 64 bit integer memory argument.
'krlnk’ points to the value of the argument.
'lnk’ points to the next ARG ILI.</p>
<p><em>Attributes</em>: define null lnk
.CG memarg “mov” ‘q’<em>ld</em> double fadd fmul fst lat(4)</p>
<p><em>st</em> double fst lat(4)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>ARGRSRV</strong> lnk    <em>Type</em>: <em>stc</em></p>
<p>For WINDOWS-ABI - reserve space in memory argument area for register arguments.
'stc’ defines the number of bytes to reserve.</p>
<p><em>Attributes</em>: define null lnk
.CG memarg notAILI</p>
</li>
<li><p><strong>DAIR</strong> ir lnk    <em>Type</em>: <em>irlnk</em></p>
<p>Define integer argument in general purpose register for a JSR or QJSR.</p>
<p><em>Attributes</em>: define null lnk
.CG “mov” ‘l’ move*direct* lat(1)</p>
<p><em>ld</em> direct lat(3)</p>
<p><em>st</em> direct lat(3)</p>
</li>
<li><p><strong>DASP</strong> sp lnk    <em>Type</em>: <em>splnk</em></p>
<p>Define a single precision register argument for a JSR or QJSR.</p>
<p><em>Attributes</em>: define null lnk
.CG “movss” move avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</li>
<li><p><strong>DASPSP</strong> dp lnk    <em>Type</em>: <em>dplnk</em></p>
<p>Define a C struct argument of two floats, passed in the indicated xmm register.</p>
<p><em>Attributes</em>: define null lnk
.CG “movq” sse_avx*ld* double fadd fmul fst lat(4)</p>
<p><em>st</em> double fst lat(4)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>DACS</strong> cs lnk    <em>Type</em>: <em>cslnk</em></p>
<p>Define a C struct argument of two floats, passed in the indicated xmm register.</p>
<p><em>Attributes</em>: define null lnk
.CG “movsd” move sse_avx*ld* double fadd fmul fst lat(4)</p>
<p><em>st</em> double fst lat(4)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>DACD</strong> cd lnk    <em>Type</em>: <em>cdlnk</em></p>
<p>Define a C struct argument of two double, passed in the indicated xmm register.</p>
<p><em>Attributes</em>: define null lnk
.CG “movupd” move sse_avx*ld* double fadd fmul fst lat(4)</p>
<p><em>st</em> double fst lat(4)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>DADP</strong> dp lnk    <em>Type</em>: <em>dplnk</em></p>
<p>Define a double precision argument for a JSR or QJSR.</p>
<p><em>Attributes</em>: define null lnk
.CG “movsd” move avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>DA128</strong> dp lnk    <em>Type</em>: <em>dplnk</em></p>
<p>Define an __m128 argument for a JSR or QJSR.</p>
<p><em>Attributes</em>: define null lnk
.CG “movupd” move sse_avx*ld* double fadd fmul fst lat(4)</p>
<p><em>st</em> double fst lat(4)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>DA256</strong> dp lnk    <em>Type</em>: <em>dplnk</em></p>
<p>Define an __m256 argument in a ymm register for a JSR or QJSR (AVX only).</p>
<p><em>Attributes</em>: define null lnk
.CG “vmovupd” ‘y’ move avx_only*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PSARG</strong> stc lnk    <em>Type</em>: <em>xmm</em></p>
<p>Move symbolic register ‘xmm’ into actual register ‘stc’ (typically
XR_XMM0 or XR_XMM1) in preparation for call to vector intrinsic function.</p>
<p><em>Attributes</em>: define null lnk
.CG “movaps” move sse_avx*ld* double lat(4)</p>
<p><em>st</em> double lat(3)</p>
<p><em>double</em> lat(2)</p>
</li>
<li><p><strong>PDARG</strong> stc lnk    <em>Type</em>: <em>xmm</em></p>
<p>Move symbolic register ‘xmm’ into actual register ‘stc’ (typically
XR_XMM0 or XR_XMM1) in preparation for call to vector intrinsic function.</p>
<p><em>Attributes</em>: define null lnk
.CG “movapd” move ssedp sse_avx*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>DAAR</strong> ar lnk    <em>Type</em>: <em>arlnk</em></p>
<p>Define argument in address register for a JSR or QJSR.
Lnk1 points to the expression to be moved into the specified (ar2)
address register. Lnk3 locates the next argument for the JSR.</p>
<p><em>Attributes</em>: define null lnk
.CG notCG replaceby DAKR</p>
</li>
<li><p><strong>DAKR</strong> kr lnk    <em>Type</em>: <em>krlnk</em></p>
<p>Define argument in integer64 register for a JSR or QJSR.</p>
<p><em>Attributes</em>: define null lnk
.CG “mov” ‘q’ move*ld* double fadd fmul fst lat(4)</p>
<p><em>st</em> double fst lat(4)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>DFRIR</strong> ir    <em>Type</em>: <em>lnk</em></p>
<p>Define function result in a integer register.</p>
<p><em>Attributes</em>: define null ir cse
.CG terminal asm_nop ‘l’</p>
</li>
<li><p><strong>DFRSP</strong> sp    <em>Type</em>: <em>lnk</em></p>
<p>Define single precision function result.</p>
<p><em>Attributes</em>: define null sp cse
.CG terminal asm_nop</p>
</li>
<li><p><strong>DFRDP</strong> dp    <em>Type</em>: <em>lnk</em></p>
<p>Define double precision function result in an xmm register.</p>
<p><em>Attributes</em>: define null dp cse
.CG terminal asm_nop</p>
</li>
<li><p><strong>DFRCS</strong> cs    <em>Type</em>: <em>lnk</em></p>
<p>Define single precision complex function result in an xmm register.</p>
<p><em>Attributes</em>: define null cs cse
.CG terminal asm_nop</p>
</li>
<li><p><strong>DFRCD</strong> cd    <em>Type</em>: <em>lnk</em></p>
<p>Define double precision complex function result in an xmm register.</p>
<p><em>Attributes</em>: define null cd cse
.CG terminal asm_nop</p>
</li>
<li><p><strong>DFR128</strong> dp    <em>Type</em>: <em>lnk</em></p>
<p>Define 128-bit function result in an xmm register.</p>
<p><em>Attributes</em>: define null dp cse
.CG terminal asm_nop</p>
</li>
<li><p><strong>DFR256</strong> dp    <em>Type</em>: <em>lnk</em></p>
<p>Define 256-bit function result in an ymm register.</p>
<p><em>Attributes</em>: define null dp cse
.CG terminal asm_nop ‘y’ avx_only</p>
</li>
<li><p><strong>DFRAR</strong> ar    <em>Type</em>: <em>lnk</em></p>
<p>Define function result in an address register.
'op1’ points to one of the JSR ILI.</p>
<p><em>Attributes</em>: define null ar cse
.CG notCG replaceby DFRKR</p>
</li>
<li><p><strong>DFRKR</strong> kr    <em>Type</em>: <em>lnk</em></p>
<p>Define function result in a integer64 register.</p>
<p><em>Attributes</em>: define null kr cse
.CG terminal asm_nop ‘q’</p>
</li>
<li><p><strong>STSPSP</strong> arlnk nme stc    <em>Type</em>: <em>dplnk</em></p>
<p>Store the result of a function returning a struct of two floats.
dplnk always points to a DFRDP or DPDF ili.
stc is always MSZ_F8.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movq” ssest sse_avx*ld* double fadd fmul fst lat(4)</p>
<p><em>st</em> double fst lat(4)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">IRDF</span></code></dt><dd><p>Define one of the 64-bit general purpose registers.</p>
<p><em>Attributes</em>: define null ir cse
.CG terminal asm_nop ‘l’</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SPDF</span></code></dt><dd><p>Define single precision register (xmm register).</p>
<p><em>Attributes</em>: define null sp cse
.CG terminal asm_nop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DPDF</span></code></dt><dd><p>Define double precision register (xmm register).</p>
<p><em>Attributes</em>: define null dp cse
.CG terminal asm_nop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARDF</span></code></dt><dd><p>Define address register. (ar is actual register number).</p>
<p><em>Attributes</em>: define null ar cse
.CG notCG replaceby KRDF</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">KRDF</span></code></dt><dd><p>Define integer64 register.</p>
<p><em>Attributes</em>: define null kr
.CG terminal asm_nop ‘q’</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>MVIR</strong> ir    <em>Type</em>: <em>irlnk</em></p>
<p>Move integer value into specific integer register, ir.</p>
<p><em>Attributes</em>: move null trm
.CG terminal notAILI ‘l’</p>
</li>
<li><p><strong>MVSP</strong> sp    <em>Type</em>: <em>splnk</em></p>
<p>This ili represents a single precision function return value.
For X86_64, the value is moved into the specified xmm register.</p>
<p><em>Attributes</em>: move null trm
.CG terminal “movss” move avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</li>
<li><p><strong>MVSPSP</strong> dp    <em>Type</em>: <em>dplnk</em></p>
<p>Move two single precision values to the lower 64 bits of the
specified xmm register.  dplnk always points to a LDDP ili.</p>
<p><em>Attributes</em>: move null trm
.CG terminal “movq” sse_avx*ld* double fadd fmul fst lat(4)</p>
<p><em>st</em> double fst lat(4)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>SPSP2SCMPLX</strong> splnk    <em>Type</em>: <em>splnk</em></p>
<p>Form a single complex value out of two single precision real values.</p>
<p><em>Attributes</em>: other null cs cse
.CG “unpcklps” sse_avx asm_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">SPSP2SCMPLXI0</span></code></dt><dd><p>Form a single complex value out of two single precision real values, imaginary part is 0.</p>
<p><em>Attributes</em>: other null cs cse
.CG “unpcklps” sse_avx asm_special</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>DPDP2DCMPLX</strong> dplnk    <em>Type</em>: <em>dplnk</em></p>
<p>Form a double complex value out of two double precision real values.</p>
<p><em>Attributes</em>: other null cd cse
.CG “unpcklpd” sse_avx asm_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DPDP2DCMPLXI0</span></code></dt><dd><p>Form a double complex value out of two double precision real values, imaginary part is 0.</p>
<p><em>Attributes</em>: other null cd cse
.CG “unpcklpd” sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLX2IMAG</span></code></dt><dd><p>Return single precision imaginary part of a single complex value.</p>
<p><em>Attributes</em>: other null sp cse
.CG “movshdup” sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLX2IMAG</span></code></dt><dd><p>Return double precision imaginary part of a double complex value.</p>
<p><em>Attributes</em>: other null dp cse
.CG “unpckhpd” sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SCMPLX2REAL</span></code></dt><dd><p>Return single precision real part of a single complex value.</p>
<p><em>Attributes</em>: other null sp cse
.CG “movss” sse_avx asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DCMPLX2REAL</span></code></dt><dd><p>Return double precision real part of a double complex value.</p>
<p><em>Attributes</em>: other null dp cse
.CG “movsd” sse_avx asm_special</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>MVDP</strong> dp    <em>Type</em>: <em>dplnk</em></p>
<p>This ili represents a double precision function return value.
For X86_64, the value is moved into the specified xmm register.</p>
<p><em>Attributes</em>: move null trm
.CG terminal “movsd” move avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>MVQ</strong> dp    <em>Type</em>: <em>dplnk</em></p>
<p>This ili represents an __m128 function return value.
For X86_64, the value is moved into the specified xmm register.</p>
<p><em>Attributes</em>: move null trm
.CG terminal “movapd” move sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>MV256</strong> dp    <em>Type</em>: <em>dplnk</em></p>
<p>This ili represents an __m256 function return value.
For X86_64, the value is moved into the specified ymm register.</p>
<p><em>Attributes</em>: move null trm
.CG terminal “vmovapd” ‘y’ move avx_only*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">MOVSP</span></code></dt><dd><p>Move a single-precision xmm register value.</p>
<p><em>Attributes</em>: move null sp
.CG CGonly “movss” move avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOVDP</span></code></dt><dd><p>Move a double-precision xmm register value.</p>
<p><em>Attributes</em>: move null dp
.CG CGonly “movsd” move avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOVCS</span></code></dt><dd><p>Move a single-precision complex xmm register value.</p>
<p><em>Attributes</em>: move null cs
.CG CGonly “movsd” move avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOVCD</span></code></dt><dd><p>Move a double-precision complex xmm register value.</p>
<p><em>Attributes</em>: move null cd
.CG CGonly “movupd” move sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOVQP</span></code></dt><dd><p>Move an __m128 xmm register value.</p>
<p><em>Attributes</em>: move null dp
.CG CGonly “movapd” move sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOV256</span></code></dt><dd><p>Move an __m256 ymm register value.</p>
<p><em>Attributes</em>: move null dp
.CG CGonly “vmovapd” ‘y’ move avx_only*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>MVAR</strong> ar    <em>Type</em>: <em>arlnk</em></p>
<p>Move address value into specific address register, ar.</p>
<p><em>Attributes</em>: move null trm
.CG terminal notCG replaceby MVKR</p>
</li>
<li><p><strong>MVKR</strong> kr    <em>Type</em>: <em>krlnk</em></p>
<p>Move integer value into specific integer register, kr.</p>
<p><em>Attributes</em>: move null trm
.CG terminal notAILI ‘q’</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FREEIR</span></code></dt><dd><p>Ensures that the result reg is freed.
The FREExx ili are eliminated by the linearizer phase of the code generator.</p>
<p><em>Attributes</em>: other null trm
.CG terminal notAILI</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">FREESP</span></code></p>
<blockquote>
<div><p><em>Attributes</em>: other null trm
.CG terminal notAILI</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">FREEDP</span></code></p>
<blockquote>
<div><p><em>Attributes</em>: other null trm
.CG terminal notAILI</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">FREECS</span></code></p>
<blockquote>
<div><p><em>Attributes</em>: other null trm
.CG terminal notAILI</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">FREECD</span></code></p>
<blockquote>
<div><p><em>Attributes</em>: other null trm
.CG terminal notAILI</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">FREEAR</span></code></p>
<blockquote>
<div><p><em>Attributes</em>: other null trm
.CG terminal notCG replaceby FREEKR</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">FREEKR</span></code></p>
<blockquote>
<div><p><em>Attributes</em>: other null trm
.CG terminal notAILI</p>
</div></blockquote>
<ol class="arabic">
<li><p><strong>FREE</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: other null trm
.CG terminal notAILI</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ENTRY</span></code></dt><dd><p>Main function entry or fortran ENTRY.</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal asm_nop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">EXIT</span></code></dt><dd><p>Exit the procedure.</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ARGSAVE</span></code></dt><dd><p>For varargs/stdargs functions, this ili appears immediately after ENTRY
ili.  This ili stores the registers which may contain incoming arguments
into a stack array where they can be accessed by the varargs/stdarg macros.
'sym’ is a symbol table pointer to the stack array.</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal asm_special “leaq”<em>direct</em> lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">NOP</span></code></dt><dd><p>Null operation - used when a linear ilo is deleted.
Also, is the opcode for the head of the aili list.</p>
<p><em>Attributes</em>: other null trm
.CG asm_nop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ASM</span></code></dt><dd><p>Implements C inline assembly code, asm(), feature. Also used as
a convenience by the code generator.  ‘sym’ is a symbol table
pointer to a string constant.</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal asm_special</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>GASM</strong> lnk lnk lnk    <em>Type</em>: <em>sym</em></p>
<p>Compatible ASM language representation to support asm().
sym - the asm string
lnk1 - linked list of generic GASMLNKOs of output expressions
lnk2 - linked list of specific GASMLNKI/SP/DP/As of input expressions
lnk3 - linked list of generic GASMLNKCs of clobber strings
NOTE: For now we add ccmod. In the future we may only want to indicate ccmod
if the user specifies “cc” in the clobber list.</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal asm_special ccmod</p>
</li>
<li><p><strong>GASMCNM</strong> sym    <em>Type</em>: <em>sym</em></p>
<p>Used to represent a symbolic name for a gasm constraint
sym - identifier of constraint name. Stored as an int since we only care</p>
<blockquote>
<div><p>about the name, not its type.</p>
</div></blockquote>
<p>sym - constraint number</p>
<p><em>Attributes</em>: other null trm
.CG terminal asm_nop</p>
</li>
<li><p><strong>GASMLNKG</strong> nme lnk lnk    <em>Type</em>: <em>sym</em></p>
<p>generic gasmlnk;
sym - descriptor string
nme - nme being stored
lnk1 - input or output expression
lnk2 - next GASMLNKG</p>
<p><em>Attributes</em>: other null lnk
.CG asm_nop</p>
</li>
<li><p><strong>GASMLNKTYP</strong> lnk    <em>Type</em>: <em>stc</em></p>
<p>generic gasmlnk - stores type
stc - base type of expression
lnk1 - input or output expression</p>
<p><em>Attributes</em>: other null lnk
.CG asm_nop</p>
</li>
<li><p><strong>GASMLNKC</strong> lnk    <em>Type</em>: <em>sym</em></p>
<p>sym - descriptor string
lnk - next GASMLNKC</p>
<p><em>Attributes</em>: other null lnk
.CG asm_nop</p>
</li>
<li><p><strong>GASMLNKO</strong> nme lnk stc    <em>Type</em>: <em>sym</em></p>
<p>sym - descriptor string
nme - nme being stored
lnk - next GASMLNKO
stc - dtype of expression</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLNKI</strong> nme irlnk lnk    <em>Type</em>: <em>sym</em></p>
<p>Represents Word reg.
sym - descriptor string
nme - nme being stored
irlnk - the input expression
lnk - next specific GASMLNK</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLNKB</strong> nme irlnk lnk    <em>Type</em>: <em>sym</em></p>
<p>Same as GASMLNKI, but represents byte reg
sym - descriptor string
nme - nme being stored
irlnk - the input expression
lnk - next specific GASMLNK</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLNKH</strong> nme irlnk lnk    <em>Type</em>: <em>sym</em></p>
<p>Same as GASMLNKI, but represents Half-word reg
sym - descriptor string
nme - nme being stored
irlnk - the input expression
lnk - next specific GASMLNK</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLNKKR</strong> nme krlnk lnk    <em>Type</em>: <em>sym</em></p>
<p>Same as GASMLNKI, but represents quad word reg
sym - descriptor string
nme - nme being stored
krlnk - the input expression
lnk - next specific GASMLNK</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLNKSP</strong> nme splnk lnk    <em>Type</em>: <em>sym</em></p>
<p>sym - descriptor string
nme - nme being stored
splnk - the input expression
lnk - next specific GASMLNK</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLNKDP</strong> nme dplnk lnk    <em>Type</em>: <em>sym</em></p>
<p>sym - descriptor string
nme - nme being stored
dplnk - the input expression
lnk - next specific GASMLNK</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLNK256</strong> nme dplnk lnk    <em>Type</em>: <em>sym</em></p>
<p>__m256
sym - descriptor string
nme - nme being stored
dplnk - the input expression
lnk - next specific GASMLNK</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLNKQP</strong> nme dplnk lnk    <em>Type</em>: <em>sym</em></p>
<p>__m128
sym - descriptor string
nme - nme being stored
dplnk - the input expression
lnk - next specific GASMLNK</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLNKA</strong> nme arlnk lnk    <em>Type</em>: <em>sym</em></p>
<p>sym - descriptor string
nme - nme being stored
arlnk - the input expression
lnk - next specific GASMLNK</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLNKS</strong> nme arlnk lnk    <em>Type</em>: <em>sym</em></p>
<p>the operand is a struct
sym - descriptor string
nme - nme being stored
arlnk - the input expression
lnk - next specific GASMLNK</p>
<p><em>Attributes</em>: other null lnk
.CG “” asm_nop</p>
</li>
<li><p><strong>GASMLDI</strong> stc nme    <em>Type</em>: <em>stc</em></p>
<p>word register
stc - output argument number, 0..n
stc - optional field filled in by CG, this is the constaint used.
nme - nme of object we’re loading</p>
<p><em>Attributes</em>: other null ir
.CG asm_nop</p>
</li>
<li><p><strong>GASMLDH</strong> stc nme    <em>Type</em>: <em>stc</em></p>
<p>half word register
stc - output argument number, 0..n
stc - optional field filled in by CG, this is the constaint used.
nme - nme of object we’re loading</p>
<p><em>Attributes</em>: other null ir
.CG asm_nop</p>
</li>
<li><p><strong>GASMLDB</strong> stc nme    <em>Type</em>: <em>stc</em></p>
<p>byte register
stc - output argument number, 0..n
stc - optional field filled in by CG, this is the constaint used.
nme - nme of object we’re loading</p>
<p><em>Attributes</em>: other null ir
.CG asm_nop</p>
</li>
<li><p><strong>GASMLDKR</strong> stc nme    <em>Type</em>: <em>stc</em></p>
<p>quad register
stc - output argument number, 0..n
stc - optional field filled in by CG, this is the constaint used.
nme - nme of object we’re loading</p>
<p><em>Attributes</em>: other null kr
.CG asm_nop</p>
</li>
<li><p><strong>GASMLDSP</strong> stc nme    <em>Type</em>: <em>stc</em></p>
<p>stc - output argument number, 0..n
stc - optional field filled in by CG, this is the constaint used.
nme - nme of object we’re loading</p>
<p><em>Attributes</em>: other null sp
.CG asm_nop</p>
</li>
<li><p><strong>GASMLDDP</strong> stc nme    <em>Type</em>: <em>stc</em></p>
<p>stc - output argument number, 0..n
stc - optional field filled in by CG, this is the constaint used.
nme - nme of object we’re loading</p>
<p><em>Attributes</em>: other null dp
.CG asm_nop</p>
</li>
<li><p><strong>GASMLDQP</strong> stc nme    <em>Type</em>: <em>stc</em></p>
<p>128-bit object (typically used for XMM reg)
stc - output argument number, 0..n
stc - optional field filled in by CG, this is the constaint used.
nme - nme of object we’re loading</p>
<p><em>Attributes</em>: other null dp
.CG asm_nop</p>
</li>
<li><p><strong>GASMLD256</strong> stc nme    <em>Type</em>: <em>stc</em></p>
<p>256-bit object (typically used for YMM reg)
stc - output argument number, 0..n
stc - optional field filled in by CG, this is the constaint used.
nme - nme of object we’re loading</p>
<p><em>Attributes</em>: other null dp
.CG asm_nop</p>
</li>
<li><p><strong>GASMLDA</strong> stc nme    <em>Type</em>: <em>stc</em></p>
<p>stc - output argument number, 0..n
stc - optional field filled in by CG, this is the constaint used.
nme - nme of object we’re loading</p>
<p><em>Attributes</em>: other null ar
.CG asm_nop</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">FPSAVE</span></code></dt><dd><p>Store the frame pointer in the location whose address is specified
by op1.</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal notAILI</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">VFENTER</span></code></dt><dd><p>Enter a “function” which will compute the value of an expression
used as a variable format field. op1 locates a temporary area
used to set up the environment of the expression:</p>
<blockquote>
<div><p>op1+0 – contains the fp to use for the expression
op1+4 – where to save the current fp</p>
</div></blockquote>
<p>The code for VFENTER performs the following:
1.  save current fp in addr(op1)+4
2.  load fp from addr(op1)+0</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal asm_special</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>VFEXIT</strong> irlnk    <em>Type</em>: <em>arlnk</em></p>
<p>Exit the variable format field function.  lnk1 locates the temporary
area (see VFENTER).  lnk2 is the function return value. The code for
VFEXIT performs the following:
1.  value of lnk2 –&gt; integer function return register
2.  restore fp from addr(lnk1)+4
3.  return.</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal asm_special</p>
</li>
<li><p><strong>PREFETCHNTA</strong> stc nme    <em>Type</em>: <em>arlnk</em></p>
<p>Prefetch cache line.  Non-Temporal Access - prefetch in such a way to
minimize cache pollution.  Second operand, ‘stc’ is not used.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “prefetchnta”<em>direct</em> lat(20)</p>
</li>
<li><p><strong>PREFETCHT0</strong> stc nme    <em>Type</em>: <em>arlnk</em></p>
<p>Prefetch cache line into all cache levels.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “prefetcht0”<em>direct</em> lat(20)</p>
</li>
<li><p><strong>PREFETCHW</strong> stc nme    <em>Type</em>: <em>arlnk</em></p>
<p>Prefetch cache line into L1 data cache.  Used in anticipation to subsequent
store into the cache line.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “prefetchw”<em>direct</em> lat(20)</p>
</li>
<li><p><strong>PREFETCH</strong> stc nme    <em>Type</em>: <em>arlnk</em></p>
<p>Prefetch cache line into L1 data cache.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “prefetch”<em>direct</em> lat(20)</p>
</li>
<li><p><strong>BPREFETCHI</strong> irlnk sym    <em>Type</em>: <em>irlnk</em></p>
<p>This ILI immediately precedes a sequence of PREFETCHxx ILIs.  During
linearisation it is replaced by:</p>
<blockquote>
<div><p>if ( irlnk1 != irlnk2 ) goto sym</p>
</div></blockquote>
<p>where ‘sym’ is a label which immediately follows the last prefetch in
the sequence (at the position marked by an EPREFETCH ILI).</p>
<p><em>Attributes</em>: other null trm dom
.CG notCG terminal</p>
</li>
<li><p><strong>BPREFETCHK</strong> krlnk sym    <em>Type</em>: <em>krlnk</em></p>
<p>This is the same as BPREFETCHI except that the first two operands are
‘krlnk’s instead of ‘irlnk’s.</p>
<p><em>Attributes</em>: other null trm dom
.CG notCG terminal</p>
</li>
<li><p><strong>EPREFETCH</strong> sym    <em>Type</em>: <em>sym</em></p>
<p>This ILI immediately follows a sequence of PREFETCHxx ILIs.  ‘sym1’ is
a label which is the target of the conditional jump from a BPREFETCH
ILI.  If ( sym2 != sym1 ) then the label ‘sym1’ is immediately preceded
by an unconditional jump to ‘sym2’.</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal asm_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">LABEL</span></code></dt><dd><p>This ILI represents a label ‘sym’ that is within a basic block.</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal asm_special</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PSLD</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load packed real*4 values from address ‘arlnk’ into ‘xmm’.  ‘xmm’ may
be an xmm, ymm or zmm register and ‘arlnk’ must be 16, 32 or 64-byte
aligned respectively.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “movaps” move sse_avx*ld* double lat(4)</p>
<p><em>st</em> double lat(3)</p>
<p><em>double</em> lat(2)</p>
</li>
<li><p><strong>PDLD</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load packed real*8 values from address ‘arlnk’ into ‘xmm’.  ‘xmm’ may
be an xmm, ymm or zmm register and ‘arlnk’ must be 16, 32 or 64-byte
aligned respectively.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “movapd” move ssedp sse_avx*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PI4LD</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load packed integer*4 values from address ‘arlnk’ into ‘xmm’.  ‘xmm’
may be an xmm, ymm or zmm register and ‘arlnk’ must be 16, 32 or
64-byte aligned respectively.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “movdqa” move ssedp avx3_special*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PI8LD</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load packed integer*8 values from address ‘arlnk’ into ‘xmm’.  ‘xmm’
may be an xmm, ymm or zmm register and ‘arlnk’ must be 16, 32 or
64-byte aligned respectively.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “movdqa” move ssedp avx3_special*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PILD</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load packed integer*4 or integer*8 values from address ‘arlnk’ into
‘xmm’.  ‘xmm’ may be an xmm, ymm or zmm register and ‘arlnk’ must be
16, 32 or 64-byte aligned respectively.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “movdqa” move ssedp sse_avx*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PSLDU</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load packed real*4 values from address ‘arlnk’ into ‘xmm’.  ‘xmm’ may
be an xmm, ymm or zmm register and there are no alignment requirements
for ‘arlnk’.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “movups” move sse_avx</p>
</li>
<li><p><strong>PDLDU</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load packed real*8 values from address ‘arlnk’ into ‘xmm’.  ‘xmm’ may
be an xmm, ymm or zmm register and there are no alignment requirements
for ‘arlnk’.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “movupd” move ssedp sse_avx</p>
</li>
<li><p><strong>PI4LDU</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load packed integer*4 values from address ‘arlnk’ into ‘xmm’.  ‘xmm’
may be an xmm, ymm or zmm register and there are no alignment
requirements for ‘arlnk’.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “movdqu” move ssedp avx3_special</p>
</li>
<li><p><strong>PI8LDU</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load packed integer*8 values from address ‘arlnk’ into ‘xmm’.  ‘xmm’
may be an xmm, ymm or zmm register and there are no alignment
requirements for ‘arlnk’.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “movdqu” move ssedp avx3_special</p>
</li>
<li><p><strong>PILDU</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load packed integer*4 or integer*8 values from address ‘arlnk’ into
‘xmm’.  ‘xmm’ may be an xmm, ymm or zmm register and there are no
alignment requirements for ‘arlnk’.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “movdqu” move ssedp sse_avx</p>
</li>
<li><p><strong>PSMASKLD</strong> xmm nme xmm    <em>Type</em>: <em>arlnk</em></p>
<p>Conditionally load packed real*4 elements from the 16-byte (for xmm)
or 32-byte (for ymm) memory location whose starting address is given
by ‘arlnk’ into the corresponding elements of the destination register
‘xmm1’, under the control of a mask in ‘xmm2’.  The mask bit for each
real*4 element is the most significant bit of that element in the mask
register ‘xmm2’.  If a mask bit is 1 then the corresponding real*4
element is copied from memory to ‘xmm1’, otherwise that element of
‘xmm1’ is set to 0.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “vmaskmovps” avx_only</p>
</li>
<li><p><strong>PDMASKLD</strong> xmm nme xmm    <em>Type</em>: <em>arlnk</em></p>
<p>Conditionally load packed real*8 elements from the 16-byte (for xmm)
or 32-byte (for ymm) memory location whose starting address is given
by ‘arlnk’ into the corresponding elements of the destination register
‘xmm1’, under the control of a mask in ‘xmm2’.  The mask bit for each
real*8 element is the most significant bit of that element in the mask
register ‘xmm2’.  If a mask bit is 1 then the corresponding real*8
element is copied from memory to ‘xmm1’, otherwise that element of
‘xmm1’ is set to 0.</p>
<p><em>Attributes</em>: pload null trm ssenme
.CG terminal “vmaskmovpd” ssedp avx_only</p>
</li>
<li><p><strong>PSLD_SCALAR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Move 4-byte scalar value whose address is indicated by arlnk,
into least significant word of the 16-byte xmm register indicated by ‘xmm’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movss” avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</li>
<li><p><strong>PSLD_LOWH</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load 2 single precision values to low half of xmm register.
This opcode and the next are used in combination, in place of “movups”
due to a Hammer performance penalty for using “movups”.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movlps” avx_special</p>
</li>
<li><p><strong>PSLD_HIGHH</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load 2 single precision values to high half of xmm register.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movhps” avx_special</p>
</li>
<li><p><strong>PDLD_LOWH</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load 8 bytes from memory into low half of xmm register denoted by xmm.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movlpd” ssedp avx_special*ld* direct fadd fmul fst lat(4)</p>
<p><em>st</em> direct fst lat(2)</p>
</li>
<li><p><strong>PDLD_HIGHH</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Load 8 bytes from memory into high half of xmm register denoted by xmm.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movhpd” ssedp avx_special*ld* direct fadd fmul fst lat(4)</p>
<p><em>st</em> direct fst lat(2)</p>
</li>
<li><p><strong>PI1INSERT</strong> xmm nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 and AVX instruction to load an integer*1 value from ‘arlnk’ and
insert it into ‘xmm’ at the byte offset given by ‘stc’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pinsrb” sse_avx asm_special</p>
</li>
<li><p><strong>PI2INSERT</strong> xmm nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 and AVX instruction to load an integer*2 value from ‘arlnk’ and
insert it into ‘xmm’ at the word offset given by ‘stc’ (where a ‘word’
is 2 bytes).</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pinsrw” sse_avx asm_special</p>
</li>
<li><p><strong>PI4INSERT</strong> xmm nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 and AVX instruction to load an integer*4 value from ‘arlnk’ and
insert it into ‘xmm’ at the dword offset given by ‘stc’ (where a
‘dword’ is 4 bytes).</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pinsrd” sse_avx asm_special</p>
</li>
<li><p><strong>PI8INSERT</strong> xmm nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 and AVX instruction to load an integer*8 value from ‘arlnk’ and
insert it into ‘xmm’ at the qword offset given by ‘stc’ (where a
‘qword’ is 8 bytes).  This instruction can only be used on x86-64.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pinsrq” sse_avx asm_special</p>
</li>
<li><p><strong>PSST</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store packed real*4 values from ‘xmm’ to address ‘arlnk’.  ‘xmm’ may
be an xmm, ymm or zmm register and ‘arlnk’ must be 16, 32 or 64-byte
aligned respectively.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movaps” move ssest sse_avx*ld* double lat(4)</p>
<p><em>st</em> double lat(3)</p>
<p><em>double</em> lat(2)</p>
</li>
<li><p><strong>PDST</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store packed real*8 values from ‘xmm’ to address ‘arlnk’.  ‘xmm’ may
be an xmm, ymm or zmm register and ‘arlnk’ must be 16, 32 or 64-byte
aligned respectively.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movapd” move ssedp ssest sse_avx*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PI4ST</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store packed integer*4 values from ‘xmm’ to address ‘arlnk’.  ‘xmm’
may be an xmm, ymm or zmm register and ‘arlnk’ must be 16, 32 or
64-byte aligned respectively.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movdqa” move ssedp ssest avx3_special*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PI8ST</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store packed integer*8 values from ‘xmm’ to address ‘arlnk’.  ‘xmm’
may be an xmm, ymm or zmm register and ‘arlnk’ must be 16, 32 or
64-byte aligned respectively.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movdqa” move ssedp ssest avx3_special*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PIST</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store packed integer*4 or integer*8 values from ‘xmm’ to address
‘arlnk’.  ‘xmm’ may be an xmm, ymm or zmm register and ‘arlnk’ must be
16, 32 or 64-byte aligned respectively.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movdqa” move ssedp ssest sse_avx*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PSSTU</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store packed real*4 values from ‘xmm’ to address ‘arlnk’.  ‘xmm’ may
be an xmm, ymm or zmm register and there are no alignment requirements
for ‘arlnk’.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movups” move ssest sse_avx</p>
</li>
<li><p><strong>PDSTU</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store packed real*8 values from ‘xmm’ to address ‘arlnk’.  ‘xmm’ may
be an xmm, ymm or zmm register and there are no alignment requirements
for ‘arlnk’.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movupd” move ssedp ssest sse_avx</p>
</li>
<li><p><strong>PI4STU</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store packed integer*4 values from ‘xmm’ to address ‘arlnk’.  ‘xmm’
may be an xmm, ymm or zmm register and there are no alignment
requirements for ‘arlnk’.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movdqu” move ssedp ssest avx3_special</p>
</li>
<li><p><strong>PI8STU</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store packed integer*8 values from ‘xmm’ to address ‘arlnk’.  ‘xmm’
may be an xmm, ymm or zmm register and there are no alignment
requirements for ‘arlnk’.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movdqu” move ssedp ssest avx3_special</p>
</li>
<li><p><strong>PISTU</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store packed integer*4 or integer*8 values from ‘xmm’ to address
‘arlnk’.  ‘xmm’ may be an xmm, ymm or zmm register and there are no
alignment requirements for ‘arlnk’.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movdqu” move ssedp ssest sse_avx</p>
</li>
<li><p><strong>PSMASKST</strong> xmm nme xmm    <em>Type</em>: <em>arlnk</em></p>
<p>Conditionally store packed real*4 elements from the source register
‘xmm1’ into the corresponding elements of the 16-byte (for xmm) or
32-byte (for ymm) memory location whose starting address is given by
‘arlnk’, under the control of a mask in ‘xmm2’.  The mask bit for each
real*4 element is the most significant bit of that element in the mask
register ‘xmm2’.  If a mask bit is 1 then the corresponding real*4
element is copied from ‘xmm1’ to memory, otherwise that element of
memory is left unchanged.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “vmaskmovps” ssest avx_only</p>
</li>
<li><p><strong>PDMASKST</strong> xmm nme xmm    <em>Type</em>: <em>arlnk</em></p>
<p>Conditionally store packed real*8 elements from the source register
‘xmm1’ into the corresponding elements of the 16-byte (for xmm) or
32-byte (for ymm) memory location whose starting address is given by
‘arlnk’, under the control of a mask in ‘xmm2’.  The mask bit for each
real*8 element is the most significant bit of that element in the mask
register ‘xmm2’.  If a mask bit is 1 then the corresponding real*8
element is copied from ‘xmm1’ to memory, otherwise that element of
memory is left unchanged.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “vmaskmovpd” ssedp ssest avx_only</p>
</li>
<li><p><strong>PSSTS</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Streaming store.
Store 16 bytes from xmm register denoted by xmm into aligned memory
bypassing cache.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movntps” move ssest sse_avx</p>
</li>
<li><p><strong>PSSTS_SCALAR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Scalar streaming store single precision quantity.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movntss” move ssest</p>
</li>
<li><p><strong>SSTS_SCALAR</strong> arlnk nme stc    <em>Type</em>: <em>splnk</em></p>
<p>Scalar streaming store single precision quantity.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “movntss” move</p>
</li>
<li><p><strong>PDSTS</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Streaming store.
Store 16 bytes from xmm register denoted by xmm into aligned memory
bypassing cache.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movntpd” move ssedp ssest sse_avx</p>
</li>
<li><p><strong>PDSTS_SCALAR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Scalar streaming store double precision quantity.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movntsd” move ssedp ssest</p>
</li>
<li><p><strong>DSTS_SCALAR</strong> arlnk nme    <em>Type</em>: <em>dplnk</em></p>
<p>Scalar streaming store double precision quantity.</p>
<p><em>Attributes</em>: store null trm
.CG terminal “movntsd” move</p>
</li>
<li><p><strong>PISTS</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Streaming store.  Store 16 bytes, 4 or byte integer, from xmm register
denoted by xmm into aligned memory, bypassing cache.</p>
<p><em>Attributes</em>: pstore null trm ssenme
.CG terminal “movntdq” move ssedp ssest sse_avx</p>
</li>
<li><p><strong>PSST_SCALAR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store value from xmm register into 4-byte variable.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movss” move ssest avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</li>
<li><p><strong>PDST_LOWH</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store low half of xmm register into 8-byte memory location.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movsd” move ssedp ssest avx_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PDST_HIGHH</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store high half of xmm register into 8-byte memory location.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movhpd” ssedp ssest avx_special*ld* direct fadd fmul fst lat(4)</p>
<p><em>st</em> direct fst lat(2)</p>
</li>
<li><p><strong>PSST_LOWH</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store 2 single precision values from low half of xmm register.
This opcode and the next are used in combination, in place of “movups”
due to a Hammer performance penalty for using “movups”.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movlps” ssest avx_special</p>
</li>
<li><p><strong>PSST_HIGHH</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Store 2 single precision values from high half of xmm register.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “movhps” ssest avx_special</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">SFENCE</span></code></dt><dd><p>X86 sfence instruction used in conjunction with streaming stores.</p>
<p><em>Attributes</em>: other null trm dom
.CG terminal “sfence”</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>PSMOVX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Move low order 4 byte value of xmm1 into low order 4 bytes of xmm2,
without disturbing the other 12 bytes of xmm2.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movss” avx_special*ld* double lat(4)</p>
<p><em>st</em> double lat(3)</p>
<p><em>double</em> lat(2)</p>
</li>
<li><p><strong>PSMOV</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Copy the packed real*4 values from ‘xmm1’ to ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movaps” move sse_avx*ld* double lat(4)</p>
<p><em>st</em> double lat(3)</p>
<p><em>double</em> lat(2)</p>
</li>
<li><p><strong>PDMOV</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Copy the packed real*8 values from ‘xmm1’ to ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movapd” move ssedp sse_avx*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PI4MOV</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Copy the packed integer*4 values from ‘xmm1’ to ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movdqa” move avx3_special*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PI8MOV</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Copy the packed integer*8 values from ‘xmm1’ to ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movdqa” move avx3_special*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>PIMOV</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Copy the packed integer*4 or integer*8 values from ‘xmm1’ to ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movdqa” move sse_avx*ld* double fadd fmul fst lat(2)</p>
<p><em>st</em> double fst lat(3)</p>
<p><em>double</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>MOVSHDUP</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>‘xmm1’ and ‘xmm2’ contain packed real*4 values.  This sets:</dt><dd><p>xmm2(3:0) = [ xmm1(3), xmm1(3), xmm1(1), xmm1(1) ]</p>
</dd>
</dl>
<p>where the subscripts refer to real*4 elements.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movshdup” sse_avx</p>
</li>
<li><p><strong>MOVSLDUP</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>‘xmm1’ and ‘xmm2’ contain packed real*4 values.  This sets:</dt><dd><p>xmm2(3:0) = [ xmm1(2), xmm1(2), xmm1(0), xmm1(0) ]</p>
</dd>
</dl>
<p>where the subscripts refer to real*4 elements.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movsldup” sse_avx</p>
</li>
<li><p><strong>MOVDDUP</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>‘xmm1’ and ‘xmm2’ contain packed real*8 values.  This sets:</dt><dd><p>xmm2(1:0) = [ xmm1(0), xmm1(0) ]</p>
</dd>
</dl>
<p>where the subscripts refer to real*8 elements.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movddup” ssedp sse_avx</p>
</li>
<li><p><strong>PSDFR</strong> xmm    <em>Type</em>: <em>stc</em></p>
<p>Move 16-byte register ‘stc’ containing result of vector intrinsic function,
into symbolic register ‘xmm’.  ‘stc’ is typically XR_XMM0.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movaps” move sse_avx</p>
</li>
<li><p><strong>PDDFR</strong> xmm    <em>Type</em>: <em>stc</em></p>
<p>Move 16-byte register ‘stc’ containing result of vector intrinsic function,
into symbolic register ‘xmm’.  ‘stc’ is typically XR_XMM0.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movapd” move ssedp sse_avx</p>
</li>
<li><p><strong>PSMV_LOW</strong> xmm    <em>Type</em>: <em>splnk</em></p>
<p>Copy a real*4 value into the bottom of an ‘xmm’ register.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movss” move avx_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</li>
<li><p><strong>PDMV_LOWH</strong> xmm    <em>Type</em>: <em>dplnk</em></p>
<p>Copy a real*8 value into the low half of an ‘xmm’ register.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movlpd” move ssedp avx_special*ld* direct fadd fmul fst lat(4)</p>
<p><em>st</em> direct fst lat(2)</p>
</li>
<li><p><strong>PDMV_HIGHH</strong> xmm    <em>Type</em>: <em>dplnk</em></p>
<p>Copy a real*8 value into the high half of an ‘xmm’ register.  If the
input operand is a register, the “unpcklpd” instruction is used instead.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movhpd” ssedp avx_special*ld* direct fadd fmul fst lat(4)</p>
<p><em>st</em> direct fst lat(2)</p>
</li>
<li><p><strong>PDMV_DUP</strong> xmm    <em>Type</em>: <em>dplnk</em></p>
<p>Copy a real*8 value into both the low and high halves of an ‘xmm’ register.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movddup” ssedp sse_avx*double* fmul lat(4)</p>
</li>
<li><p><strong>PSCMPLXMV_LOWH</strong> xmm    <em>Type</em>: <em>cslnk</em></p>
<p>Copy a complex*8 value into the low half of an ‘xmm’ register.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movlps” move avx_special</p>
</li>
<li><p><strong>PDCMPLXMV</strong> xmm    <em>Type</em>: <em>cdlnk</em></p>
<p>Copy a complex*16 value into an ‘xmm’ register.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movupd” move sse_avx</p>
</li>
<li><p><strong>PI4MV_LOW</strong> xmm    <em>Type</em>: <em>irlnk</em></p>
<p>Copy an integer*4 value into the bottom of an ‘xmm’ register with zero
extension to 16 bytes.  E.g. llvect uses this followed by PI4SHUF to
store 4 copies of an integer*4 value in an ‘xmm’ register.  Typically
this is done in the preheader of a vectorised loop to initialise the
register for packed integer*4 operations.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movd” ‘l’ sse_avx asm_special</p>
</li>
<li><p><strong>PI8MV_LOW</strong> xmm    <em>Type</em>: <em>krlnk</em></p>
<p>Copy an integer*8 value into the low half of an ‘xmm’ register with
zero extension to 16 bytes.  E.g. llvect uses this followed by
UNPCKLQDQ to store 2 copies of an integer*8 value in an ‘xmm’
register.  Typically this is done in the preheader of a vectorised
loop to initialise the register for packed integer*8 operations.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movd” ‘q’ sse_avx asm_special</p>
</li>
<li><p><strong>MOVHLPS</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Move high half of sp values from one xmm register into a low half of 2nd
xmm register.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movhlps” sse_avx</p>
</li>
<li><p><strong>MOVLHPS</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Move low half of sp values from one xmm register into a high half of 2nd
xmm register.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “movlhps” sse_avx</p>
</li>
<li><p><strong>UNPCKLPS</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>‘xmm1’ and ‘xmm2’ contain packed real*4 values.  This sets:</dt><dd><p>xmm2(3:0) = [ xmm1(1), xmm2(1), xmm1(0), xmm2(0) ]</p>
</dd>
</dl>
<p>where the subscripts refer to real*4 elements.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “unpcklps” sse_avx</p>
</li>
<li><p><strong>UNPCKHPS</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>‘xmm1’ and ‘xmm2’ contain packed real*4 values.  This sets:</dt><dd><p>xmm2(3:0) = [ xmm1(3), xmm2(3), xmm1(2), xmm2(2) ]</p>
</dd>
</dl>
<p>where the subscripts refer to real*4 elements.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “unpckhps” sse_avx</p>
</li>
<li><p><strong>UNPCKLPD</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>‘xmm1’ and ‘xmm2’ contain packed real*8 values.  This sets:</dt><dd><p>xmm2(1:0) = [ xmm1(0), xmm2(0) ]</p>
</dd>
</dl>
<p>where the subscripts refer to real*8 elements.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “unpcklpd” ssedp sse_avx</p>
</li>
<li><p><strong>UNPCKHPD</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>‘xmm1’ and ‘xmm2’ contain packed real*8 values.  This sets:</dt><dd><p>xmm2(1:0) = [ xmm1(1), xmm2(1) ]</p>
</dd>
</dl>
<p>where the subscripts refer to real*8 elements.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “unpckhpd” ssedp sse_avx</p>
</li>
<li><p><strong>UNPCKLDQ</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>‘xmm1’ and ‘xmm2’ contain packed integer*4 values.  This sets:</dt><dd><p>xmm2(3:0) = [ xmm1(1), xmm2(1), xmm1(0), xmm2(0) ]</p>
</dd>
</dl>
<p>where the subscripts refer to integer*4 elements.  This is only used
in AILIs on x86-32, where it is generated from a PI8MV_LOW ILI.</p>
<p><em>Attributes</em>: other null trm
.CG CGonly terminal “punpckldq” ssedp sse_avx</p>
</li>
<li><p><strong>UNPCKHQDQ</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>‘xmm1’ and ‘xmm2’ contain packed integer*8 values.  This sets:</dt><dd><p>xmm2(1:0) = [ xmm1(1), xmm2(1) ]</p>
</dd>
</dl>
<p>where the subscripts refer to integer*8 elements.  This is only used
in AILIs on x86-64, where it is generated from a PDFLOATK ILI.</p>
<p><em>Attributes</em>: other null trm
.CG CGonly terminal “punpckhqdq” ssedp sse_avx</p>
</li>
<li><p><strong>UNPCKLQDQ</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>‘xmm1’ and ‘xmm2’ contain packed integer*8 values.  This sets:</dt><dd><p>xmm2(1:0) = [ xmm1(0), xmm2(0) ]</p>
</dd>
</dl>
<p>where the subscripts refer to integer*8 elements.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “punpcklqdq” ssedp sse_avx</p>
</li>
<li><p><strong>PSSHUF</strong> xmm stc    <em>Type</em>: <em>xmm</em></p>
<p>Shuffle contents of xmm registers.  Used to move value in
least significant word into the 3 other words of a register:
xmm1 and xmm2 denote the (same) xmm register, and stc3 is the
immediate constant 0.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “shufps” sse_avx asm_special</p>
</li>
<li><p><strong>PDSHUF</strong> xmm stc    <em>Type</em>: <em>xmm</em></p>
<p>Shuffle contents of xmm registers.  Used to switch 2 d.p. values
in register.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “shufpd” ssedp sse_avx asm_special</p>
</li>
<li><p><strong>PI4SHUF</strong> xmm stc    <em>Type</em>: <em>xmm</em></p>
<p>Shuffle contents of xmm register containing 4-byte integers.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pshufd” sse_avx asm_special</p>
</li>
<li><p><strong>PTEST</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>This sets the ZF flag if the bitwise AND of all the bits in the xmm
register operands is 0, otherwise it clears the ZF flag, and it sets
the CF flag if the bitwise ANDN of all the bits in the operands is 0,
otherwise it clears the CF flag.  Due to the latter operation its
operands are not commutative.  It clears the AF, OF, PF and SF flags.</p>
<p><em>Attributes</em>: other null ir
.CG “ptest” ccmod sse_avx asm_special</p>
</li>
<li><p><strong>PI4ADD</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed signed or unsigned integer*4 addition.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “paddd” sse_avx</p>
</li>
<li><p><strong>PI4AND</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed bitwise AND.  For pre-AVX512 targets the same instruction
‘[v]pand’ is generated for all integer sizes, but for AVX512 the
letter ‘d’ is added to the instruction mnemonic to denote integer*4
operands and result.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “pand” avx3_special</p>
</li>
<li><p><strong>PI4ANDN</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed bitwise AND NOT.  For pre-AVX512 targets the same
instruction ‘[v]pandn’ is generated for all integer sizes, but for
AVX512 the letter ‘d’ is added to the instruction mnemonic to denote
integer*4 operands and result.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pandn” avx3_special</p>
</li>
<li><p><strong>PI4MAX</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 packed signed integer*4 maximum.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “pmaxsd” sse_avx</p>
</li>
<li><p><strong>PI4MIN</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 packed signed integer*4 minimum.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “pminsd” sse_avx</p>
</li>
<li><p><strong>PI4MUL</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 packed signed integer*4 multiplication, yielding the low half
of the integer*8 result.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “pmulld” sse_avx</p>
</li>
<li><p><strong>PI4OR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed bitwise OR.  For pre-AVX512 targets the same instruction
‘[v]por’ is generated for all integer sizes, but for AVX512 the letter
‘d’ is added to the instruction mnemonic to denote integer*4 operands
and result.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “por” avx3_special</p>
</li>
<li><p><strong>PI4SUBR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed signed or unsigned integer*4 reverse subtraction.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “psubd” sse_avx</p>
</li>
<li><p><strong>PI4XOR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed bitwise XOR.  For pre-AVX512 targets the same instruction
‘[v]pxor’ is generated for all integer sizes, but for AVX512 the
letter ‘d’ is added to the instruction mnemonic to denote integer*4
operands and result.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “pxor” avx3_special</p>
</li>
<li><p><strong>PI4ADDX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed signed or unsigned integer*4 addition.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “paddd” sse_avx</p>
</li>
<li><p><strong>PI4ANDX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed bitwise AND.  For pre-AVX512 targets the same instruction
‘[v]pand’ is generated for all integer sizes, but for AVX512 the
letter ‘d’ is added to the instruction mnemonic to denote integer*4
operands and result.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “pand” avx3_special</p>
</li>
<li><p><strong>PI4ANDNX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed bitwise AND NOT.  For pre-AVX512 targets the same
instruction ‘[v]pandn’ is generated for all integer sizes, but for
AVX512 the letter ‘d’ is added to the instruction mnemonic to denote
integer*4 operands and result.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pandn” avx3_special</p>
</li>
<li><p><strong>PI4MAXX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE4.1 packed signed integer*4 maximum.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “pmaxsd” sse_avx</p>
</li>
<li><p><strong>PI4MINX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE4.1 packed signed integer*4 minimum.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “pminsd” sse_avx</p>
</li>
<li><p><strong>PI4MULX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE4.1 packed signed integer*4 multiplication, yielding the low half
of the integer*8 result.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “pmulld” sse_avx</p>
</li>
<li><p><strong>PI4ORX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed bitwise OR.  For pre-AVX512 targets the same instruction
‘[v]por’ is generated for all integer sizes, but for AVX512 the letter
‘d’ is added to the instruction mnemonic to denote integer*4 operands
and result.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “por” avx3_special</p>
</li>
<li><p><strong>PI4SUBRX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed signed or unsigned integer*4 reverse subtraction.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “psubd” sse_avx</p>
</li>
<li><p><strong>PI4XORX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed bitwise XOR.  For pre-AVX512 targets the same instruction
‘[v]pxor’ is generated for all integer sizes, but for AVX512 the
letter ‘d’ is added to the instruction mnemonic to denote integer*4
operands and result.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “pxor” avx3_special</p>
</li>
<li><p><strong>PI8ADD</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed signed or unsigned integer*8 addition.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “paddq” sse_avx</p>
</li>
<li><p><strong>PI8AND</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed bitwise AND.  For pre-AVX512 targets the same instruction
‘[v]pand’ is generated for all integer sizes, but for AVX512 the
letter ‘q’ is added to the instruction mnemonic to denote integer*8
operands and result.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “pand” avx3_special</p>
</li>
<li><p><strong>PI8ANDN</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed bitwise AND NOT.  For pre-AVX512 targets the same
instruction ‘[v]pandn’ is generated for all integer sizes, but for
AVX512 the letter ‘q’ is added to the instruction mnemonic to denote
integer*8 operands and result.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pandn” avx3_special</p>
</li>
<li><p><strong>PI8OR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed bitwise OR.  For pre-AVX512 targets the same instruction
‘[v]por’ is generated for all integer sizes, but for AVX512 the letter
‘q’ is added to the instruction mnemonic to denote integer*8 operands
and result.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “por” avx3_special</p>
</li>
<li><p><strong>PI8SUBR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed signed or unsigned integer*8 reverse subtraction.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “psubq” sse_avx</p>
</li>
<li><p><strong>PI8XOR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE2 packed bitwise XOR.  For pre-AVX512 targets the same instruction
‘[v]pxor’ is generated for all integer sizes, but for AVX512 the
letter ‘q’ is added to the instruction mnemonic to denote integer*8
operands and result.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “pxor” avx3_special</p>
</li>
<li><p><strong>PI8ADDX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed signed or unsigned integer*8 addition.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “paddq” sse_avx</p>
</li>
<li><p><strong>PI8ANDX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed bitwise AND.  For pre-AVX512 targets the same instruction
‘[v]pand’ is generated for all integer sizes, but for AVX512 the
letter ‘q’ is added to the instruction mnemonic to denote integer*8
operands and result.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “pand” avx3_special</p>
</li>
<li><p><strong>PI8ANDNX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed bitwise AND NOT.  For pre-AVX512 targets the same
instruction ‘[v]pandn’ is generated for all integer sizes, but for
AVX512 the letter ‘q’ is added to the instruction mnemonic to denote
integer*8 operands and result.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pandn” avx3_special</p>
</li>
<li><p><strong>PI8ORX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed bitwise OR.  For pre-AVX512 targets the same instruction
‘[v]por’ is generated for all integer sizes, but for AVX512 the letter
‘q’ is added to the instruction mnemonic to denote integer*8 operands
and result.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “por” avx3_special</p>
</li>
<li><p><strong>PI8SUBRX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed signed or unsigned integer*8 reverse subtraction.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “psubq” sse_avx</p>
</li>
<li><p><strong>PI8XORX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE2 packed bitwise XOR.  For pre-AVX512 targets the same instruction
‘[v]pxor’ is generated for all integer sizes, but for AVX512 the
letter ‘q’ is added to the instruction mnemonic to denote integer*8
operands and result.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “pxor” avx3_special</p>
</li>
<li><p><strong>PI4CMPX</strong> xmm stc    <em>Type</em>: <em>xmm</em></p>
<p>Vector dword integer compare; stc is the compare code;
one of the instructions pcmpXXd is generated for this ili.</p>
<p><em>Attributes</em>: other null trm
.CG terminal sse_avx asm_special</p>
</li>
<li><p><strong>PI8CMPX</strong> xmm stc    <em>Type</em>: <em>xmm</em></p>
<p>Vector qword integer compare; stc is the compare code;
one of the instructions pcmpXXq is generated for this ili.</p>
<p><em>Attributes</em>: other null trm
.CG terminal sse_avx asm_special</p>
</li>
<li><p><strong>PUI4MAXX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE4.1 packed unsigned dword integer maximum.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “pmaxud”</p>
</li>
<li><p><strong>PUI4MINX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE4.1 packed unsigned dword integer minimum.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “pminud”</p>
</li>
<li><p><strong>PUI4MAX</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 packed unsigned dword integer maximum.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “pmaxud”</p>
</li>
<li><p><strong>PUI4MIN</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 packed unsigned dword integer minimum.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “pminud”</p>
</li>
<li><p><strong>PSADD</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Perform 4 single-precision floating-point adds of the 4 values
in the 16-byte aligned memory location denoted by arlnk, and
the 4 values in the xmm register denoted by xmm.
The results are placed in xmm register ‘xmm’.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “addps” sse_avx*double* fadd lat(7:5)</p>
</li>
<li><p><strong>PSSUBR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Reverse subtract: computes ‘xmm’ - ‘arlnk’, result placed in the
xmm register denoted by ‘xmm’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “subps” sse_avx*double* fadd lat(7:5)</p>
</li>
<li><p><strong>PSMUL</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Multiply contents of memory and 16-byte xmm register.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “mulps” sse_avx*double* fmul lat(7:5)</p>
</li>
<li><p><strong>PSDIVR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Reverse divide: op2/op1 -&gt; op2.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “divps” sse_avx*double* fmul lat(35:33)</p>
</li>
<li><p><strong>PSAND</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Bitwise AND operation on s.p. values - used to implement absolute value.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “andps” sse_avx*double* fmul lat(5:3)</p>
</li>
<li><p><strong>PSXOR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Bitwise XOR operation on s.p. values.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “xorps” sse_avx*double* fmul lat(5:3)</p>
</li>
<li><p><strong>PSMAX</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Single-precision packed maximum.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “maxps” sse_avx*double* fadd lat(5:3)</p>
</li>
<li><p><strong>PSMIN</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Single-precison packed minimum.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “minps” sse_avx*double* fadd lat(5:3)</p>
</li>
<li><p><strong>PSSQRT</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Compute square root of 4 s.p. values in memory and put result into
xmm register denoted by xmm.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “sqrtps” sse_avx*double* fmul lat(41:39)</p>
</li>
<li><p><strong>RCPPS</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Compute single-precision approximations to reciprocal.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “rcpps” avx3_special*double* fmul lat(41:39)</p>
</li>
<li><p><strong>RSQRTPS</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Compute single-precision approximations to reciprocal square root.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “rsqrtps” avx3_special*double* fmul lat(41:39)</p>
</li>
<li><p><strong>CMPNEQPS</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Used for single-precision sqrt approximation.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “cmpneqps” sse_avx*double* fadd lat(5:3)</p>
</li>
<li><p><strong>HADDPS</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Horizontal add packed single.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “haddps” sse_avx</p>
</li>
<li><p><strong>PSADDX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Perform 4 single-precision floating point additions of the 4
values in xmm register xmm1 and the 4 values in register xmm2.
The results are placed in register xmm2.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “addps” sse_avx*double* fadd lat(7:5)</p>
</li>
<li><p><strong>PSADDSUBX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>‘xmm1’ and ‘xmm2’ contain packed real*4 values.  This subtracts the
even-index values in ‘xmm1’ from the corresponding values in ‘xmm2’,
and adds the odd-index values in ‘xmm1’ to the corresponding values in
‘xmm2’, placing the result in ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “addsubps” sse_avx*double* fadd lat(5:7)</p>
</li>
<li><p><strong>PSSUBRX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Reverse-subtract contents of two 16-byte xmm registers.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “subps” sse_avx*double* fadd lat(7:5)</p>
</li>
<li><p><strong>PSMULX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Multiply contents of two 16-byte xmm registers.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “mulps” sse_avx*double* fmul lat(7:5)</p>
</li>
<li><p><strong>PSDIVRX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Reverse-divide contents of two 16-byte xmm registers.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “divps” sse_avx*double* fmul lat(35:33)</p>
</li>
<li><p><strong>PSANDX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Bitwise AND operation on s.p. values - used to implement absolute value.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “andps” sse_avx*double* fmul lat(5:3)</p>
</li>
<li><p><strong>PSANDNX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Bitwise ANDNOT operation on s.p. values.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “andnps” sse_avx*double* fmul lat(5:3)</p>
</li>
<li><p><strong>PSORX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Bitwise OR operation on s.p. values.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “orps” sse_avx*double* fadd lat(5:3)</p>
</li>
<li><p><strong>PSXORX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Compute bitwise exclusive-OR of two xmm registers and place result
in second register.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “xorps” sse_avx*double* fmul lat(5:3)</p>
</li>
<li><p><strong>PSMAXX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Single precision packed maximum.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “maxps” sse_avx*double* fadd lat(5:3)</p>
</li>
<li><p><strong>PSMINX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Single precision packed minimum.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “minps” sse_avx*double* fadd lat(5:3)</p>
</li>
<li><p><strong>PSSQRTX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Compute square root of 4 s.p. values in 1st xmm register and put result into
2nd xmm register.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “sqrtps” sse_avx*double* fmul lat(41:39)</p>
</li>
<li><p><strong>RCPPSX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Compute single-precision approximations to reciprocal.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “rcpps” avx3_special*double* fmul lat(41:39)</p>
</li>
<li><p><strong>RSQRTPSX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Compute single-precision approximations to reciprocal square root.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “rsqrtps” avx3_special*double* fmul lat(41:39)</p>
</li>
<li><p><strong>CMPNEQPSX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Used for single-precision square root approximation.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “cmpneqps” sse_avx</p>
</li>
<li><p><strong>PSCMPX</strong> xmm stc    <em>Type</em>: <em>xmm</em></p>
<p>Vector compare of single precision values.  ‘stc’ is comparison code.
One of the instructions cmpXXps is generated for this ili.</p>
<p><em>Attributes</em>: other null trm
.CG terminal sse_avx asm_special</p>
</li>
<li><p><strong>PDADD</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Perform 2 double-precision floating-point adds of the 2 values
in the 16-byte aligned memory location denoted by arlnk, and
the 2 values in the xmm register denoted by xmm.
The results are placed in xmm register ‘xmm’.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “addpd” ssedp sse_avx*double* fadd lat(7:5)</p>
</li>
<li><p><strong>PDSUBR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Reverse subtract: computes ‘xmm’ - ‘arlnk’, result placed in the
xmm register denoted by ‘xmm’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “subpd” ssedp sse_avx*double* fadd lat(7:5)</p>
</li>
<li><p><strong>PDMUL</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Multiply contents of memory and 16-byte xmm register.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “mulpd” ssedp sse_avx*double* fmul lat(7:5)</p>
</li>
<li><p><strong>PDDIVR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Reverse divide: op2/op1 -&gt; op2.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “divpd” ssedp sse_avx*double* fmul lat(39:37)</p>
</li>
<li><p><strong>PDAND</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Bitwise AND operation on d.p. values - used to implement absolute value.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “andpd” ssedp sse_avx*direct* fadd lat(5:3)</p>
</li>
<li><p><strong>PDXOR</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Bitwise XOR operation on d.p. values.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “xorpd” ssedp sse_avx*double* fmul lat(5:3)</p>
</li>
<li><p><strong>PDMAX</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Double precision packed maximum.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “maxpd” ssedp sse_avx*direct* fadd lat(5:3)</p>
</li>
<li><p><strong>PDMIN</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Double precision packed minimum.</p>
<p><em>Attributes</em>: other comm trm ssenme
.CG terminal “minpd” ssedp sse_avx*direct* fadd lat(5:3)</p>
</li>
<li><p><strong>PDSQRT</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>Compute square root of 2 d.p. values in memory and put result into
xmm register denoted by xmm.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “sqrtpd” ssedp sse_avx*double* fmul lat(53:51)</p>
</li>
<li><p><strong>HADDPD</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Horizontal add packed double.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “haddpd” ssedp sse_avx</p>
</li>
<li><p><strong>PDADDX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Perform 2 double-precision floating point additions of the 2
values in xmm register xmm1 and the 2 values in register xmm2.
The results are placed in register xmm2.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “addpd” ssedp sse_avx*double* fadd lat(5:7)</p>
</li>
<li><p><strong>PDADDSUBX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>‘xmm1’ and ‘xmm2’ contain packed real*8 values.  This subtracts the
even-index values in ‘xmm1’ from the corresponding values in ‘xmm2’,
and adds the odd-index values in ‘xmm1’ to the corresponding values in
‘xmm2’, placing the result in ‘xmm2’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “addsubpd” ssedp sse_avx*double* fadd lat(5:7)</p>
</li>
<li><p><strong>PDSUBRX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Reverse-subtract contents of two 16-byte xmm registers.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “subpd” ssedp sse_avx*double* fadd lat(7:5)</p>
</li>
<li><p><strong>PDMULX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Multiply contents of two 16-byte xmm registers.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “mulpd” ssedp sse_avx*double* fmul lat(7:5)</p>
</li>
<li><p><strong>PDDIVRX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Reverse-divide contents of two 16-byte xmm registers.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “divpd” ssedp sse_avx*double* fmul lat(39:37)</p>
</li>
<li><p><strong>PDANDX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Bitwise AND operation on d.p. values - used to implement absolute value.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “andpd” ssedp sse_avx*direct* fadd lat(5:3)</p>
</li>
<li><p><strong>PDANDNX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Bitwise ANDNOT operation on d.p. values.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “andnpd” ssedp sse_avx</p>
</li>
<li><p><strong>PDORX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Bitwise OR operation on d.p. values.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “orpd” ssedp sse_avx</p>
</li>
<li><p><strong>PDXORX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Compute bitwise exclusive-OR of two xmm registers and place result
in second register.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “xorpd” ssedp sse_avx*double* fmul lat(5:3)</p>
</li>
<li><p><strong>PDMAXX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Double precision packed maximum.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “maxpd” ssedp sse_avx*double* fadd lat(5:3)</p>
</li>
<li><p><strong>PDMINX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Double precision packed minimum.</p>
<p><em>Attributes</em>: other comm trm
.CG terminal “minpd” ssedp sse_avx*double* fadd lat(5:3)</p>
</li>
<li><p><strong>PDSQRTX</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>Compute square root of 2 d.p. values in 1st xmm register and put result into
2nd xmm register.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “sqrtpd” ssedp sse_avx*double* fmul lat(53:51)</p>
</li>
<li><p><strong>PDCMPX</strong> xmm stc    <em>Type</em>: <em>xmm</em></p>
<p>Vector compare of double precision values.  ‘stc’ is comparison code.
One of the instructions cmpXXpd is generated for this ili.</p>
<p><em>Attributes</em>: other null trm
.CG terminal sse_avx asm_special ssedp</p>
</li>
<li><p><strong>PSLLSH</strong> xmm    <em>Type</em>: <em>irlnk</em></p>
<p>Shift packed 4-byte integers left.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pslld” sse_avx</p>
</li>
<li><p><strong>PSRLSH</strong> xmm    <em>Type</em>: <em>irlnk</em></p>
<p>Shift packed 4-byte integers logical right (zero fill).</p>
<p><em>Attributes</em>: other null trm
.CG terminal “psrld” sse_avx</p>
</li>
<li><p><strong>PSRASH</strong> xmm    <em>Type</em>: <em>irlnk</em></p>
<p>Shift packed 4-byte integers arithmetically right (sign extend).</p>
<p><em>Attributes</em>: other null trm
.CG terminal “psrad” sse_avx</p>
</li>
<li><p><strong>PDLLSH</strong> xmm    <em>Type</em>: <em>irlnk</em></p>
<p>Shift packed 8-byte integers left.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “psllq” ssedp sse_avx</p>
</li>
<li><p><strong>PDRLSH</strong> xmm    <em>Type</em>: <em>irlnk</em></p>
<p>Shift packed 8-byte integers logical right (zero fill).</p>
<p><em>Attributes</em>: other null trm
.CG terminal “psrlq” ssedp sse_avx</p>
</li>
<li><p><strong>PDRASH</strong> xmm    <em>Type</em>: <em>irlnk</em></p>
<p>Shift packed 8-byte integers arithmetically right (sign extend).
NO SUCH INSTRUCTION.</p>
<p><em>Attributes</em>: other null trm
.CG notCG terminal “psraq” ssedp</p>
</li>
<li><p><strong>PBBLENDX</strong> xmm xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE4.1 Variable Blend Packed Bytes</p>
<p><em>Attributes</em>: other null trm
.CG terminal “pblendvb” sse_avx asm_special</p>
</li>
<li><p><strong>PDBLENDX</strong> xmm xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE4.1 Variable Blend Packed Double Precision Floating-Point Values</p>
<p><em>Attributes</em>: other null trm
.CG terminal “blendvpd” sse_avx asm_special ssedp</p>
</li>
<li><p><strong>PSBLENDX</strong> xmm xmm    <em>Type</em>: <em>xmm</em></p>
<p>SSE4.1 Variable Blend Packed Single Precision Floating-Point Values</p>
<p><em>Attributes</em>: other null trm
.CG terminal “blendvps” sse_avx asm_special</p>
</li>
<li><p><strong>PBBLEND</strong> xmm nme xmm    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 Variable Blend Packed Bytes</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “pblendvb” sse_avx asm_special</p>
</li>
<li><p><strong>PDBLEND</strong> xmm nme xmm    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 Variable Blend Packed Double Precision Floating-Point Values</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “blendvpd” sse_avx asm_special ssedp</p>
</li>
<li><p><strong>PSBLEND</strong> xmm nme xmm    <em>Type</em>: <em>arlnk</em></p>
<p>SSE4.1 Variable Blend Packed Single Precision Floating-Point Values</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “blendvps” sse_avx asm_special</p>
</li>
<li><p><strong>PDBROADCAST</strong> xmm    <em>Type</em>: <em>dplnk</em></p>
<p>An AVX-only ILI which broadcasts a real*8 value to all 8-byte elements
of a ymm or zmm register ‘xmm’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vbroadcastsd” ssedp avx_only avx_special</p>
</li>
<li><p><strong>PSBROADCAST</strong> xmm    <em>Type</em>: <em>splnk</em></p>
<p>An AVX-only ILI which broadcasts a real*4 value to all 4-byte elements
of an xmm, ymm or zmm register ‘xmm’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vbroadcastss” avx_only avx_special</p>
</li>
<li><p><strong>PCDBROADCAST</strong> xmm    <em>Type</em>: <em>cdlnk</em></p>
<p>An AVX-only ILI which broadcasts a (real*8, real*8) complex value to
all 16-byte elements of a zmm register ‘xmm’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vbroadcastf32x4” ssedp avx_only avx_special</p>
</li>
<li><p><strong>PCSBROADCAST</strong> xmm    <em>Type</em>: <em>cslnk</em></p>
<p>An AVX-only ILI which broadcasts a (real*4, real*4) complex value to
all 8-byte elements of a ymm or zmm register ‘xmm’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vbroadcastsd” avx_only avx_special</p>
</li>
<li><p><strong>PI4BROADCAST</strong> xmm    <em>Type</em>: <em>irlnk</em></p>
<p>An AVX-only ILI which broadcasts an integer*4 value to all 4-byte
elements of an xmm, ymm or zmm register ‘xmm’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vpbroadcastd” avx_only avx_special</p>
</li>
<li><p><strong>PI8BROADCAST</strong> xmm    <em>Type</em>: <em>krlnk</em></p>
<p>An AVX-only ILI which broadcasts an integer*8 value to all 8-byte
elements of an xmm, ymm or zmm register ‘xmm’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vpbroadcastq” avx_only avx_special</p>
</li>
<li><p><strong>VEXTRACT</strong> xmm nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>An AVX-only ILI.  stc = (suffix_flag | n), where ‘suffix_flag’ is a
flag such as SUF_f128 that specifies which ‘vextract…’ instruction
to use and ‘n’ is an integer in the range 0-3.  ‘xmm’ is a ymm or zmm
source register, and this ILI stores the contents of its n’th 128-bit
or 256-bit element to the address ‘arlnk’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “vextract” avx_only avx_special</p>
</li>
<li><p><strong>VEXTRACTX</strong> xmm stc    <em>Type</em>: <em>xmm</em></p>
<p>This is the same as VEXTRACT except that the destination is ‘xmm2’ (an
xmm or ymm register) rather than the address ‘arlnk’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vextract” avx_only avx_special</p>
</li>
<li><p><strong>VINSERT</strong> xmm nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>An AVX-only ILI.  stc = (suffix_flag | n), where ‘suffix_flag’ is a
flag such as SUF_f128 that specifies which ‘vinsert…’ instruction to
use and ‘n’ is an integer in the range 0-3.  This ILI loads 128 or 256
bits of data from address ‘arlnk’ to the n’th 128-bit or 256-bit
element of ‘xmm’, which is a ymm or zmm register, leaving its other
element(s) unchanged.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “vinsert” avx_only avx_special</p>
</li>
<li><p><strong>VINSERTX</strong> xmm stc    <em>Type</em>: <em>xmm</em></p>
<p>This is the same as VINSERT except that the source is ‘xmm1’ (an xmm
or ymm register) rather than the address ‘arlnk’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vinsert” avx_only avx_special</p>
</li>
<li><p><strong>VEXTRACTF128</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>An AVX-only ILI.  Store the high lane of ‘xmm’ (a ymm register
containing floating-point data) to the address ‘arlnk’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “vextractf128” avx_only avx_special</p>
</li>
<li><p><strong>VEXTRACTF128X</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>An AVX-only ILI.  Copy the high lane of ‘xmm1’ (a ymm register
containing floating-point data) to ‘xmm2’ (an xmm register).</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vextractf128” avx_only avx_special</p>
</li>
<li><p><strong>VEXTRACTI128</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>An AVX2-only ILI.  Store the high lane of ‘xmm’ (a ymm register
containing integer data) to the address ‘arlnk’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “vextracti128” avx_only avx_special</p>
</li>
<li><p><strong>VEXTRACTI128X</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>An AVX2-only ILI.  Copy the high lane of ‘xmm1’ (a ymm register
containing integer data) to ‘xmm2’ (an xmm register).</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vextracti128” avx_only avx_special</p>
</li>
<li><p><strong>VINSERTF128</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>An AVX-only ILI.  Load 128 bits of floating-point data from address
‘arlnk’ to the high lane of ‘xmm’ (a ymm register), leaving its low
lane unchanged.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “vinsertf128” avx_only avx_special</p>
</li>
<li><p><strong>VINSERTF128X</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>An AVX-only ILI.  Copy the contents of ‘xmm1’ (an xmm register
containing floating-point data) to the high lane of ‘xmm2’ (a ymm
register), leaving its low lane unchanged.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vinsertf128” avx_only avx_special</p>
</li>
<li><p><strong>VINSERTI128</strong> xmm nme    <em>Type</em>: <em>arlnk</em></p>
<p>An AVX2-only ILI.  Load 128 bits of integer data from address ‘arlnk’ to
the high lane of ‘xmm’ (a ymm register), leaving its low lane unchanged.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal “vinserti128” avx_only avx_special</p>
</li>
<li><p><strong>VINSERTI128X</strong> xmm    <em>Type</em>: <em>xmm</em></p>
<p>An AVX2-only ILI.  Copy the contents of ‘xmm1’ (an xmm register
containing integer data) to the high lane of ‘xmm2’ (a ymm register),
leaving its low lane unchanged.</p>
<p><em>Attributes</em>: other null trm
.CG terminal “vinserti128” avx_only avx_special</p>
</li>
<li><p><strong>PDFMA</strong> xmm nme xmm    <em>Type</em>: <em>arlnk</em></p>
<dl class="simple">
<dt>A packed real*8 FMA3 or FMA4 instruction which computes:</dt><dd><p>dest = &lt;sign&gt; (factor1 * factor2) &lt;addop&gt; term</p>
</dd>
<dt>where:</dt><dd><p>arlink = factor2 or term
xmm1   = ((arlnk == factor2) ? term : factor2)
xmm2   = dest</p>
</dd>
</dl>
<p>Since ILIs have a maximum of 4 operands this ILI is always immediately
preceded by an FMATYPE ILI which provides other information about the
FMA instruction, namely (i) flags to specify the values of &lt;sign&gt;
(+/-) and &lt;addop&gt; (+/-), and whether ‘dest’ is the same as ‘factor1’
or ‘term’, and for P[DS]FMA, whether arlnk is ‘factor2’ or ‘term’, and
(ii) the ‘factor1’ operand.</p>
<p>Note, for FMA3 ‘dest’ must be the same as either ‘factor1’ or ‘term’.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal asm_special ssedp</p>
</li>
<li><p><strong>PDFMAX</strong> xmm xmm xmm    <em>Type</em>: <em>xmm</em></p>
<dl class="simple">
<dt>A packed real*8 FMA3 or FMA4 instruction which computes:</dt><dd><p>dest = &lt;sign&gt; (factor1 * factor2) &lt;addop&gt; term</p>
</dd>
<dt>where:</dt><dd><p>xmm1 = factor1
xmm2 = factor2
xmm3 = term
xmm4 = dest</p>
</dd>
</dl>
<p>Since ILIs have a maximum of 4 operands this ILI is always immediately
preceded by an FMATYPE ILI which specifies the values of &lt;sign&gt; (+/-)
and &lt;addop&gt; (+/-).</p>
<p>Note, for FMA3 ‘dest’ must be the same as either ‘factor1’ or ‘term’.</p>
<p><em>Attributes</em>: other null trm
.CG terminal asm_special ssedp</p>
</li>
<li><p><strong>PSFMA</strong> xmm nme xmm    <em>Type</em>: <em>arlnk</em></p>
<p>This is the same as PDFMA except that it specifies a packed real*4
FMA3 or FMA4 instruction.</p>
<p><em>Attributes</em>: other null trm ssenme
.CG terminal asm_special</p>
</li>
<li><p><strong>PSFMAX</strong> xmm xmm xmm    <em>Type</em>: <em>xmm</em></p>
<p>This is the same as PDFMAX except that it specifies a packed real*4
FMA3 or FMA4 instruction.</p>
<p><em>Attributes</em>: other null trm
.CG terminal asm_special</p>
</li>
<li><p><strong>FMATYPE</strong> xmm    <em>Type</em>: <em>stc</em></p>
<p>This provides extra information about the immediately following
P[DS]FMA or P[DS]FMAX ILI.  Its operands are:</p>
<dl class="simple">
<dt>stc = a set of flags which specify the values of &lt;sign&gt; (+/-) and</dt><dd><p>&lt;addop&gt; (+/-), and whether ‘dest’ is the same as ‘factor1’ or
‘term’, and for P[DS]FMA, whether arlnk is ‘factor2’ or ‘term’.
The flags are defined by ‘FMA_…’ macros in “ili.h”.</p>
</dd>
</dl>
<p>xmm = the ‘factor1’ operand for P[DS]FMA, or 0 for P[DS]FMAX.</p>
<p><em>Attributes</em>: other null trm
.CG terminal notAILI</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">CLTD</span></code></dt><dd><p>Used with signed integer divide/mod instruction.
Sign extends %eax into %edx.</p>
<p><em>Attributes</em>: other null ir
.CG CGonly “cltd” ccmod asm_special*direct* lat(1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CQTO</span></code></dt><dd><p>Used with signed integer64 divide/mod instruction.</p>
<p><em>Attributes</em>: other null kr
.CG CGonly “cqto” ccmod asm_special*direct* lat(1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CLTQ</span></code></dt><dd><p>Sign extends register %rax from 32 to 64 bits.  Used in the final peephole
pass to replace IKMV when possible.</p>
<p><em>Attributes</em>: other null trm
.CG CGonly “cltq” ccmod asm_special*direct* lat(1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMOV</span></code></dt><dd><p>Conditionally copy op2 into op1 based on condition codes.</p>
<p><em>Attributes</em>: load null ir
.CG CGonly asm_special “cmov”<em>ld</em> direct lat(4)</p>
<p><em>direct</em> lat(1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMOVSP</span></code></dt><dd><p>Single precision conditional move.  Expanded by the CG.</p>
<p><em>Attributes</em>: load null sp
.CG CGonly “movss” sse_avx asm_special*ld* double lat(3)</p>
<p><em>st</em> direct lat(2)</p>
<p><em>direct</em> lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMOVDP</span></code></dt><dd><p>Double precision conditional move.  Expanded by the CG.</p>
<p><em>Attributes</em>: load null dp
.CG CGonly “movsd” sse_avx asm_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMOVSCMPLX</span></code></dt><dd><p>Single precision complex conditional move.  Expanded by the CG.</p>
<p><em>Attributes</em>: load null cs
.CG CGonly “movsd” sse_avx asm_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMOVDCMPLX</span></code></dt><dd><p>Double precision complex conditional move.  Expanded by the CG.</p>
<p><em>Attributes</em>: load null cd
.CG CGonly “movupd” sse_avx asm_special*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CMOVLPD</span></code></dt><dd><p>Same as CMOVDP, but used when “movlpd” is preferred.</p>
<p><em>Attributes</em>: load null dp
.CG CGonly “movlpd” sse_avx asm_special*ld* direct fadd fmul fst lat(4)</p>
<p><em>st</em> direct fst lat(2)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">CSETB</span></code></dt><dd><p>Conditional set of a byte</p>
<p><em>Attributes</em>: store null ir
.CG CGonly asm_special “set”<em>ld</em> direct lat(4)</p>
<p><em>direct</em> lat(1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">INC</span></code></dt><dd><p>Increment integer register or memory operand.</p>
<p><em>Attributes</em>: arth null ir cse
.CG CGonly ccarith “inc”<em>direct</em> lat(1)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEC</span></code></dt><dd><p>Decrement integer register or memory operand.</p>
<p><em>Attributes</em>: arth null ir cse
.CG CGonly ccarith “dec”<em>direct</em> lat(1)</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>LEA</strong> stc    <em>Type</em>: <em>irlnk</em></p>
<p>32-bit load effective address instruction.  This only appears in the
linear and attributed ILIs, not the shared ILIs.  The LILI is created
by ‘cglinear.c:optimize_imul()’, in which case ‘irlnk’ is used as both
the base and index register, and ‘stc’ is the shift count, which may
be 1, 2, 4 or 8.  The AILI may be generated from a LEA LILI or it may
be created by a peephole optimisation.</p>
<p><em>Attributes</em>: arth null ir cse
.CG CGonly “lea” ‘l’<em>direct</em> lat(1)</p>
</li>
<li><p><strong>KLEA</strong> stc    <em>Type</em>: <em>krlnk</em></p>
<p>64-bit load effective address instruction.  This is only generated on
x86-64, and it only appears in the linear and attributed ILIs, not the
shared ILIs.  It is created by ‘cglinear.c:optimize_imul()’.  ‘krlnk’
is used as both the base and index register, and ‘stc’ is the shift
count, which may be 1, 2, 4 or 8.</p>
<p><em>Attributes</em>: arth null kr cse
.CG CGonly “lea” ‘q’<em>direct</em> lat(1)</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">MOV</span></code></dt><dd><p>Synonym for LD and ST, and register to register moves.</p>
<p><em>Attributes</em>: move null ir cse
.CG CGonly “mov” move*direct* lat(1)</p>
<p><em>ld</em> direct lat(3)</p>
<p><em>st</em> direct lat(3)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">MOVABS</span></code></dt><dd><p>Used in place of MOV and ACON_STATIC, etc., when a full 64-bit address
is required.  Used to support the Hammer-64 medium code model.</p>
<p><em>Attributes</em>: move null ir cse
.CG CGonly “movabs” move</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>BIH</strong> stc    <em>Type</em>: <em>stc</em></p>
<p>Created by the code generator to represent, in the linear ili and the AILI,
the beginning of a basic block.  The first operand is the bih number, and
the second is the label symbol table pointer, if any.</p>
<p><em>Attributes</em>: other null trm dom
.CG CGonly terminal asm_nop</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">DEF</span></code></dt><dd><p>Placed into the AILI to indicate the definition of a register which is
otherwise not explicitly defined (by appearing in the ‘dest’ field of
some aili).  The register allocators need this information in certain
cases.</p>
<p><em>Attributes</em>: other null trm
.CG CGonly asm_nop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">USE</span></code></dt><dd><p>Placed into the AILI to indicate the use of a register which is otherwise
not explicitly used.  The register allocators need to know this in order
to avoid a conflicting register allocation, etc.</p>
<p><em>Attributes</em>: other null trm
.CG CGonly asm_nop</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">STACK_ADJ</span></code></dt><dd><p>Placed into the AILI to indicate that the stack pointer has been
modified by the value specified in the src1 field of the aili.
No code is generated for this ili.</p>
<p><em>Attributes</em>: other null trm
.CG CGonly asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALLOC</span></code></dt><dd><p>Allocate memory for a C or C++ variable length array.
‘krlnk’ is the size.  Result is the address of the allocated memory.</p>
<p><em>Attributes</em>: arth null ar
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DEALLOC</span></code></dt><dd><p>Deallocate memory that was allocated by ALLOC.
‘arlnk’ is the memory address.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ALLOCA</span></code></dt><dd><p>Allocate memory with alloca
‘krlnk’ is the size.  Result is the address of the allocated memory.</p>
<p><em>Attributes</em>: arth null ar
.CG notAILI</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>CFA</strong> nme    <em>Type</em>: <em>arlnk</em></p>
<p>Materialize the outer call frame address as a builtin.  This is
placed into a load address register from a memory location whose address
is represented by op1.</p>
<p><em>Attributes</em>: other null ar cse
.CG ‘l’ asm_special</p>
</li>
<li><p><strong>EHRET</strong> nme    <em>Type</em>: <em>arlnk</em></p>
<p>Materialize the return address of the caller as a builtin.  This is
placed into a load address register from a memory location whose address
is represented by op1.</p>
<p><em>Attributes</em>: other null ar cse
.CG ‘l’ asm_special</p>
</li>
<li><p><strong>EHREGST</strong> sym    <em>Type</em>: <em>sym</em></p>
<p>Store implicit registers into the syms: catch_clause and caught_object</p>
<p><em>Attributes</em>: other null trm
.CG asm_special terminal</p>
</li>
<li><p><strong>EHREGLD</strong> sym    <em>Type</em>: <em>sym</em></p>
<p>Materialize the syms: catch_clause and caught_object into the two symbols
from implicit registers</p>
<p><em>Attributes</em>: other null trm
.CG asm_special terminal</p>
</li>
<li><p><strong>EHRESUME</strong> sym    <em>Type</em>: <em>sym</em></p>
<p>Resume propagation of an existing in-flight exception whose unwinding was
interrupted to run some cleanup code.</p>
<p><em>Attributes</em>: other null trm
.CG asm_special terminal</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCEL</span></code></dt><dd><p>Start a block of code to be targeted for accelerator.
Link to list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDACCEL</span></code></dt><dd><p>End a block of code to be targeted for accelerator.
Link to a list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCKERNELS</span></code></dt><dd><p>Start a block of kernels to be targeted for accelerator.
Link to a list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCENDKERNELS</span></code></dt><dd><p>End a block of kernels to be targeted for accelerator.
Link to a list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCPAR</span></code></dt><dd><p>Start a block of parallel code to be targeted for accelerator.
Link to a list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCENDPAR</span></code></dt><dd><p>End a block of parallel code to be targeted for accelerator.
Link to a list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCSCALARREG</span></code></dt><dd><p>Start a block of code to run as a scalar kernel on the accelerator.
Link to a list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCENDSCALARREG</span></code></dt><dd><p>End a block of code to run as a scalar kernel on the accelerator.
Link to a list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCSERIAL</span></code></dt><dd><p>Start a block of code to run as a serial kernel on the accelerator.
Link to a list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCENDSERIAL</span></code></dt><dd><p>End a block of code to run as a serial kernel on the accelerator.
Link to a list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCELLP</span></code></dt><dd><p>The following loop is to be targeted for the accelerator.
Link to a list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCSLOOP</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>The following loop in a serial region is to be targeted for the accelerator.
Link to a list of clauses.
The second operand is one when this loop is tightly nested in the compute construct, and zero otherwise;</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
<li><p><strong>ACCKLOOP</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>The following loop in a kernels region is to be targeted for the accelerator.
Link to a list of clauses.
The second operand is one when this loop is tightly nested in the compute construct, and zero otherwise;</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
<li><p><strong>ACCPLOOP</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>The following loop in a parallel region is to be targeted for the accelerator.
Link to a list of clauses.
The second operand is one when this loop is tightly nested in the compute construct, and zero otherwise;</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
<li><p><strong>ACCATTACH</strong> lnk lnk sym    <em>Type</em>: <em>lnk</em></p>
<p>Attach the pointer/allocatable member in an aggregate structure data variable</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCDETACH</strong> lnk lnk sym    <em>Type</em>: <em>lnk</em></p>
<p>Detach the pointer/allocatable member in an aggregate structure data variable</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCCOPY</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from host to device and back.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCCOPYIN</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from host to device.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCCOPYOUT</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from device to host.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCLOCAL</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be allocated on the device but not copied.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCCREATE</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be allocated on the device but not copied
to or from the host.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCDELETE</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be deleted from the device but not copied
to or from the host.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCPDELETE</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be deleted from the device but not copied,
unless in a data region to or from the host.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCPRESENT</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array must be present on the device.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCPCOPY</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array may be present on the device, but if not will be copied.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCPCOPYIN</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array may be present on the device, but if not will be copied in.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCPCOPYOUT</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array may be present on the device, but if not will be copied out.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.</p>
<p><em>Attributes</em>: other null lnk
Fifth arg is the policy index
.CG notCG</p>
</li>
<li><p><strong>ACCPCREATE</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array may be present on the device, but if not will be allocated,
but not copied.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCPNOT</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array may be present on the device, but if not will NOT be allocated
nor copied.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCNO_CREATE</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array may be present on the device, but if not will NOT be allocated
nor copied.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCUPDATEHOST</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from device back to host.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCUPDATESELF</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from device back to the current thread.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCUPDATEDEV</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from host to device.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCUPDATEHOSTIFP</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from device back to host, if present.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCUPDATESELFIFP</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from device back to the current thread, if present.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCUPDATEDEVIFP</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from host to device, if present.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCUPDATE</span></code></dt><dd><p>Head of a list of update clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">PCASTCOMPARE</span></code></dt><dd><p>Head of a list of PCAST compare clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCCOMPARE</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from device back to host.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>PGICOMPARE</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from device back to host.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCPRIVATE</strong> lnk lnk    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array is private to an iteration of the loop or to a worker.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fourth argument is the symbol that points to the device copy, if there is such
a symbol.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCFIRSTPRIV</strong> lnk lnk    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array is private to the workers, but initialize with values from the host.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCCACHE</strong> lnk lnk    <em>Type</em>: <em>lnk</em></p>
<p>The compiler should move the array to the highest level of the
software-managed cache.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCDEVICEPTR</strong> lnk lnk sym stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be copied from device to host.
First link is to next clause.
Second link is to the array bounds.
Third link is to ACCSYMLNK.
Fifth arg is the policy index</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCAUTO</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>The execution mode will be selected by the compiler (gang/worker/vector/seq)
First link is to next clause.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCVECTOR</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>The iterations of the loop will be executed in vector mode on the accelerator
First link is to next clause.
Second link is to the vector size expression, or to IL_NULL if not set.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCPARALLEL</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>The iterations of the loop will be executed in parallel on the accelerator.
Same as ACCGANG except for the name.
First argument is the link to the next clause.
Second argument is the number of gangs.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCGANG</strong> lnk stc stc    <em>Type</em>: <em>lnk</em></p>
<p>The iterations of the loop will be executed in across gangs on the accelerator.
First argument is the link to the next clause.
Second argument is the number of gangs.
Third argument is the device_type argument.
Fourth argument is the dimension, where the default is dimension zero (cuda X dimension).</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCGANGCHUNK</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>The gang static-scheduling chunk size.
First argument is the link to the next clause.
Second argument is the chunk size.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCWORKER</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>The iterations of the loop will be executed in across workers on the accelerator
First argument is the link to the next clause.
Second argument is the number of workers.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCSEQ</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>The iterations of the loop will be executed sequentially on the accelerator.
First argument is the link to the next clause.
Second argument is the block size, if any.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCHOST</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>The iterations of the loop will be executed on the host.
First link is the link to the next clause.
Second link is the block size, if any.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCSHORTLOOP</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>Trip count is less than the maximum size of a vector operation
(for vector schedule) or less than the maximum number of
simultaneously active parallel iterations (for parallel schedule)
First link is the link to the next clause.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCTILE</strong> lnk stc stc    <em>Type</em>: <em>lnk</em></p>
<p>Tile this loop.
First link is to the next clause.
Second link is to a list of ACCSIZE ILI.
Third argument is the tile depth.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCSIZE</strong> lnk    <em>Type</em>: <em>lnk</em></p>
<p>A size expression.
The first link is to the next size expression, if any, or to NULL.
The second link is the expression, if any, or to NULL.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCINDEPENDENT</span></code></dt><dd><p>The iterations of the loop are data-independent.
Link to the next clause.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCNUMGANGS</strong> lnk stc stc    <em>Type</em>: <em>lnk</em></p>
<p>How many gangs to instantiate.
First link is the link to the next clause.
Second argument is the number of gangs.
Third argument is the device_type argument.
Fourth argument is the dimension, where the default is dimension zero (cuda X dimension).</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCNUMWORKERS</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>How many workers to instantiate.
First link is the link to the next clause.
Second argument is the number of workers.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCVLENGTH</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>How long a vector to instantiate.
First link is the link to the next clause.
Second argument is the vector length expression.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCIF</strong> lnk    <em>Type</em>: <em>lnk</em></p>
<p>Region will execute conditionally on host or accelerator.
First link is the link to the next clause.
Second link is the conditional expression.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCDEVID</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Device ID of the device to use for this directive or construct.
First link is the link to the next clause.
Second link is the device ID expression.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCUNROLL</strong> lnk stc stc    <em>Type</em>: <em>lnk</em></p>
<p>Control loop unrolling; the 3rd element tells whether it’s the parallel, vector, or sequential loop to be unrolled
First link is the link to the next clause.
Second link is the unroll expression, which must be a constant.
Third argument is 1 to unroll sequential loop, 2 to unroll parallel/gang loop,
3 to unroll vector loop, 0 to unroll the original loop.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCKERNEL</span></code></dt><dd><p>Mark this loop as the kernel loop; link to other arguments.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCTRIPLE</strong> lnk lnk lnk    <em>Type</em>: <em>lnk</em></p>
<p>Specify bounds of sub-arrays in accelerator clauses.
First link to subsequent ACCTRIPLE.
Second link to lower bound, third to upper bound, last to stride.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCDATAREG</span></code></dt><dd><p>Generate data movement to/from accelerator.
Link to list of arguments.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCENTERDATA</span></code></dt><dd><p>Generate data movement at enter data directive.
Link to list of arguments.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCEXITDATA</span></code></dt><dd><p>Generate data movement at exit data directive.
Link to list of arguments.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCFINALEXITDATA</span></code></dt><dd><p>Generate data movement at exit data directive with finalize clause.
Link to list of arguments.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCENDDATAREG</span></code></dt><dd><p>Generate matching data movement to/from accelerator</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCPHI</strong> stc stc    <em>Type</em>: <em>lnk</em></p>
<p>PHI operator used in accelerator optimizing code generator.
Link points to ACCPHILINK, and the 2nd operand is a symbol numbering.
3rd operand is nonzero for loop header phi</p>
<p><em>Attributes</em>: other null trm
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCLHPHI</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>PHI operator for loop headers used in accelerator optimizing code generator.
Link points to ACCPHILINK, and the 2nd operand is a symbol numbering.</p>
<p><em>Attributes</em>: other null trm
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCPHILINK</strong> lnk    <em>Type</em>: <em>lnk</em></p>
<p>PHI operator for loop headers used in accelerator optimizing code generator.
First link is to next PHILINK, 2nd link is the chain to the reaching def.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCINIT</span></code></dt><dd><p>Dummy initial value for factored use-def chains.
First link is to next PHILINK, 2nd link is the chain to the reaching def.</p>
<p><em>Attributes</em>: other null trm
.CG notCG notAILI accel</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCVAR</span></code></dt><dd><p>Used in accelerator optimizing code generator, a builtin variable ref.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCLDSYM</strong> stc    <em>Type</em>: <em>stc</em></p>
<p>Used in accelerator optimizing code generator, a load of a temp variable</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCSTSYM</strong> stc stc    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator optimizing code generator, a load of a temp variable</p>
<p><em>Attributes</em>: other null trm
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCIVAL</strong> stc    <em>Type</em>: <em>stc</em></p>
<p>Used in accelerator optimizing code generator, a literal constant;
uses two operands to hold an ISZ_T value.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCJSR</strong> lnk    <em>Type</em>: <em>stc</em></p>
<p>Used in accelerator optimizing code generator, special routine call</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCRETURN</strong> lnk    <em>Type</em>: <em>stc</em></p>
<p>Used in accelerator optimizing code generator, return value from a function call
Short constant holds the return datatype.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCLOR</strong> lnk    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator optimizing code generator, logical OR</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCCAST</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator optimizing code generator, type casting</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCJMP</strong> sym    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator optimizing code generator, conditional jump
The ‘sym’ is a normally an ACBLK index.  During linearization, the ‘stc’ will
be a symbol index if positive and an ACBLK index negated if negative, until
‘acc_replace_labels’.</p>
<p><em>Attributes</em>: branch null trm
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCARG</strong> lnk    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator optimizing code generator, argument list</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCBOUND</strong> lnk stc stc    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator optimizing code generator, array bounds check.
Fields are subscript expression, ACCBOUND2, line number, array symbol</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCBOUND2</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator optimizing code generator, array bounds check.
Fields are lower bound, upper bound, subscript number.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI accel</p>
</li>
<li><p><strong>ACCWAIT</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator code, wait on the host for each kernel to finish.
Link to next argument.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCNOWAIT</span></code></dt><dd><p>Used in accelerator code, don’t wait on the host for each kernel to finish.
Link to next argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCASYNC</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator code, perform this activity asynchronously.
First link to next argument.
Second link to async expression.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCWAITDIR</span></code></dt><dd><p>Used in accelerator code, wait on the host for async activities to finish.
Link to list of clauses.</p>
<p><em>Attributes</em>: other null trm
.CG notCG notAILI</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCWAITARG</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator code, wait on the host for async activities to finish.
First link to next argument.
Second link to async expression.
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG notAILI</p>
</li>
<li><p><strong>ACCLOOP</strong> stc sym    <em>Type</em>: <em>lnk</em></p>
<p>Used in accelerator code, to generate an explicit ‘vector’ loop.
The first argument is the trip count, the second is an accelerator symbol number of the loop variable.
The third argument is the label of the exit branch.</p>
<p><em>Attributes</em>: branch null trm
.CG notCG notAILI accel</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCENDLOOP</span></code></dt><dd><p>Used in accelerator code, to end an explicit ‘vector’ loop.
The argument is the label of the top of the loop.</p>
<p><em>Attributes</em>: branch null trm
.CG notCG notAILI accel</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ARGQP</strong> lnk    <em>Type</em>: <em>dplnk</em></p>
<p>Defines a quad precision memory argument.
'dplnk’ points to the register value of the argument.
'lnk’ points to the next ARG ILI.</p>
<p><em>Attributes</em>: define null lnk
.CG memarg “movupd” sse_avx*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>ARG256</strong> lnk    <em>Type</em>: <em>dplnk</em></p>
<p>Defines a 256-bit memory argument.
'dplnk’ points to the register value of the argument.
'lnk’ points to the next ARG ILI.</p>
<p><em>Attributes</em>: define null lnk
.CG memarg “vmovupd” ‘y’ avx_only*ld* double fadd fmul fst lat(3)</p>
<p><em>st</em> direct fst lat(2)</p>
<p><em>direct</em> fadd fmul lat(2)</p>
</li>
<li><p><strong>GENARG</strong> lnk stc stc    <em>Type</em>: <em>lnk</em></p>
<p>Define an argument for a function call.
The ARG ILIs for all of a function’s arguments are linked together.
'lnk1’ points to the argument.
'lnk2’ points to the next ARG ILI.
'stc1’ is the datatype of the argument, if available
'stc2’ is the NME</p>
<p><em>Attributes</em>: define null lnk
.CG notCG</p>
</li>
<li><p><strong>GENARG2</strong> lnk stc stc    <em>Type</em>: <em>lnk</em></p>
<p>Define 2nd argument of an argument pair for a function call.
This will be linked immediately to the matching GENARG
The ARG ILIs for all of a function’s arguments are linked together.
'lnk1’ points to the argument.
'lnk2’ points to the next ARG ILI.
'stc1’ is the datatype of the argument, if available
'stc2’ is the NME</p>
<p><em>Attributes</em>: define null lnk
.CG notCG</p>
</li>
<li><p><strong>RETURN</strong> stc nme    <em>Type</em>: <em>lnk</em></p>
<p>Define return value from a function.
'lnk’ points to the return value.
'stc’ is the datatype of the argument.
'nme’ is the nme of the argument</p>
<p><em>Attributes</em>: move null trm
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">KERNEL</span></code></dt><dd><p>Start a nest of loops to be turned into CUDA kernels</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ENDKERNEL</span></code></dt><dd><p>End a nest of loops to be turned into CUDA kernels</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>KERNELBLOCK</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Block size for one kernel loop.
The constant is the loop nest level.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
<li><p><strong>KERNELGRID</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Grid size for one kernel loop.
The constant is the loop nest level.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
<li><p><strong>KERNELNEST</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>nest depth of kernel loops</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
<li><p><strong>KERNELSTREAM</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>stream argument to CUF kernel</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
<li><p><strong>KERNELDEVICE</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>device argument to CUF kernel</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
<li><p><strong>ACCIMPDATAREG</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>Generate data movement to/from accelerator.
This is for the implicit data region; the constant is normally zero,
but is ‘1’ when there is a need for a pgi_cu_init call regardless of
whether there is any data to move or allocate</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCENDIMPDATAREG</span></code></dt><dd><p>Generate matching data movement to/from accelerator
This is for the implicit data region
The short constant tells how many implicit data regions were generated</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCMIRROR</strong> lnk lnk sym    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be mirrored on the device as on the host</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCREFLECT</strong> lnk lnk sym    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array has been reflected on the device as on the host</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCREDUCTION</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Variable is a reduction variable.  ‘stc’ is the operator.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCCACHEDIR</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>Accelerator CACHE directive.
The ‘stc’ argument is normally zero, but is set to ‘1’ if this is a ‘readonly’ cache directive.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCCACHEARG</strong> lnk lnk    <em>Type</em>: <em>lnk</em></p>
<p>Accelerator CACHE argument.
First lnk argument is the link to the next ACCCACHEARG or clause.
Second is a list of ACCTRIPLE ilis for the array bounds.
Third is an ACCSYMLNK.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCHOSTDATA</span></code></dt><dd><p>Begin host data region.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCENDHOSTDATA</span></code></dt><dd><p>End host data region.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCUSEDEVICE</strong> lnk lnk sym    <em>Type</em>: <em>lnk</em></p>
<p>Use the device address of a variable or array.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCUSEDEVICEIFP</strong> lnk lnk sym    <em>Type</em>: <em>lnk</em></p>
<p>Use the device address of a variable or array, if present</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCSYMLNK</strong> lnk lnk nme    <em>Type</em>: <em>sym</em></p>
<p>This is used from a link from many other accelerator ILI to
recover the original symbol as well as a link to the address tree,
if appropriate.
Symbol is a symbol pointer.
The first link is a link to reference the symbol.
The second link is a link to reference the parent of the symbol, if the symbol was a member.
The constant value is the NME of the parent, if the symbol was a member.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCCOLLAPSE</strong> stc stc stc    <em>Type</em>: <em>lnk</em></p>
<p>Number of loops associated with the loop construct.
First link to next argument.
Second argument is the collapse depth.
Third argument is set if this is a nontightly nested loop (force)
Last argument is the device_type argument.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCDEFNONE</span></code></dt><dd><p>Tells the accelerator CG that a default-none clause is in effect.
The link is to other clauses.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ACCDEFPRESENT</span></code></dt><dd><p>Tells the accelerator CG that a default-present clause is in effect.
The link is to other clauses.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCDEVICERES</strong> lnk lnk sym    <em>Type</em>: <em>lnk</em></p>
<p>Variable or array will be resident on the device.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
<li><p><strong>ACCLINK</strong> lnk lnk sym    <em>Type</em>: <em>lnk</em></p>
<p>A link to the variable or array will be resident on the device.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ACCLOOPPRIVATE</span></code></dt><dd><p>The symbol must be made implicitly private in the containing loop.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>ACCJMPTABLE</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Used in the Accelerator CG.
A jump table.
The first link is to a linked list of ACCJMPENTRY ACLILI.
The second link is to the expression used to index the table.
The ‘stc’ is an ACBLK index of the default jump target.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
<li><p><strong>ACCJMPENTRY</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Used in the Accelerator CG.
A jump table entry.
The first link is to the next entry in a linked list of ACCJMPENTRY ACLILI.
The second link is to an ACCIVAL that contains the value to match for this jump table entry.
The ‘stc’ is an ACBLK index of this jump target.</p>
<p><em>Attributes</em>: other null lnk
.CG notCG</p>
</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">VCON</span></code></p>
<blockquote>
<div><p><em>Attributes</em>: cons null lnk cse vect
.CG notCG</p>
</div></blockquote>
<ol class="arabic">
<li><p><strong>VLD</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>For all vector ILI except VCON the last operand is the vector dtype</p>
<p><em>Attributes</em>: load null lnk vect
.CG notCG</p>
</li>
<li><p><strong>VLDU</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p><em>Attributes</em>: load null lnk vect
.CG notCG</p>
</li>
<li><p><strong>VNEG</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VADD</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth comm lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VSUB</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VMUL</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth comm lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VDIV</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Last lnk is a potential mask</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VDIVZ</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector divide where divide by zero does not fault.</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VMOD</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VMODZ</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector remainder where divide by zero does not fault.</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VCVTV</strong> stc stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth null lnk cse vect</p>
</li>
<li><p><strong>VCVTS</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VCVTR</strong> stc stc    <em>Type</em>: <em>lnk</em></p>
<p>Reinterpret the bits of a vector as if they were a different vector type.
This should always be a no-op at runtime.</p>
<p><em>Attributes</em>: arth null lnk cse vect</p>
</li>
<li><p><strong>VNOT</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VAND</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth comm lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VOR</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth comm lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VXOR</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth comm lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VCMPNEQ</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Used for single-precision square root approximation.</p>
<p><em>Attributes</em>: arth comm lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VLSHIFTV</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VRSHIFTV</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VLSHIFTS</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VRSHIFTS</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VURSHIFTS</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector unsigned (logical) right shift by a scalar</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VMIN</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector minimum</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VMAX</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector maximum</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VABS</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector absolute value</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VSQRT</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector square root</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VCOS</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector cosine - final link is potential mask as it is
for all the math intrinsic calls (will be IL_NULL if no mask)</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VSIN</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector sine</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VSINCOS</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector sine-cosine</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VASIN</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector arc sine</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VACOS</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector arc cosine</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VATAN</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector arctangent</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VATAN2</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector arctangent2</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VTAN</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector tangent</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VSINH</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector hyperbolic sine</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VCOSH</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector hyperbolic cosine</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VTANH</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector hyperbolic tangent</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VEXP</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector natural exponential</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VLOG</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector natural logarithm</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VLOG10</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector logarithm base 10</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VPOW</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector pow float lnk</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VPOWI</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector pow float to integer</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VPOWK</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector pow double to integer*8</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VPOWIS</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector pow float to scalar integer</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VPOWKS</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector pow double to scalar integer*8</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VFPOWK</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector pow float to integer*8</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VFPOWKS</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector pow float to scalar integer*8</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VDPOWI</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector pow double to integer</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VDPOWIS</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector pow double to scalar integer</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VRSQRT</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector reciprocal square root</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VFLOOR</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector floor</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VCEIL</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector ceiling</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VAINT</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector truncation</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VRCP</strong> lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector reciprocal</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VST</strong> arlnk nme stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: store null trm vect
.CG terminal notCG</p>
</li>
<li><p><strong>VSTU</strong> arlnk nme stc    <em>Type</em>: <em>lnk</em></p>
<p><em>Attributes</em>: store null trm vect
.CG terminal notCG</p>
</li>
<li><p><strong>VFMA1</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector FMA for LLVM intrinsic - lnk1*lnk2+lnk3, with stc the dtype</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VFMA2</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector FMA for LLVM intrinsic - lnk1*lnk2-lnk3, with stc the dtype</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VFMA3</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector FMA for LLVM intrinsic - -lnk1*lnk2+lnk3, with stc the dtype</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VFMA4</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector FMA for LLVM intrinsic - -lnk1*lnk2-lnk3, with stc the dtype</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VPERMUTE</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Shuffle contents of vector registers. lnk1 and lnk2 can be the same vector
or lnk2 can be null. lnk1 dtype is used as dtype for both lnk1 and lnk2,
unless lnk2 is null. stc is the result dtype, lnk3 is a vector constant
representing a mask where each field represents which L-to-R element of
concatenated &lt;lnk1,lnk2&gt; vector is to be placed in corresponding result
field. lnk3 size must match the size of the result vector, but can be
different than lnk1 and lnk2’s size.</p>
<p><em>Attributes</em>: other null lnk vect
.CG notCG</p>
</li>
<li><p><strong>VBLEND</strong> lnk lnk stc    <em>Type</em>: <em>lnk</em></p>
<p>Vector blend/select of lnk2 &amp; lnk3. lnk1 is the mask, stc is the dtype</p>
<p><em>Attributes</em>: other null lnk cse vect
.CG notCG</p>
</li>
<li><p><strong>VCMP</strong> lnk lnk stc    <em>Type</em>: <em>stc</em></p>
<p>Vector compare of lnk1 &amp; lnk2. stc1 is the condition code, stc2 is the dtype</p>
<p><em>Attributes</em>: arth null lnk cse vect
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">X87CON</span></code></dt><dd><p>x87 80-bit extended precision floating-point constant.</p>
<p><em>Attributes</em>: cons null x87 cse</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>X87LD</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load integer or floating-point data into the X87 FPU from memory.
‘stc’ is a MSZ_… memory size/type code.</p>
<p><em>Attributes</em>: load null x87
.CG asm_special</p>
</li>
<li><p><strong>X87ST</strong> arlnk nme stc    <em>Type</em>: <em>x87lnk</em></p>
<p>Store, possibly with conversion, data from the X87 FPU to memory.
‘stc’ is a MSZ_… memory size/type code.</p>
<p><em>Attributes</em>: store null trm
.CG asm_special terminal</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">X87ABS</span></code></dt><dd><p>x87 80-bit extended precision absolute value.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG “fabs”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87CHS</span></code></dt><dd><p>x87 80-bit extended precision negation.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG “fchs”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87RNDINT</span></code></dt><dd><p>x87 80-bit extended precision round to integer with current rounding mode.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG “frndint”</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>X87ADD</strong> x87lnk    <em>Type</em>: <em>x87lnk</em></p>
<p>x87 80-bit extended precision floating-point addition.</p>
<p><em>Attributes</em>: arth comm x87 cse
.CG “fadd” asm_special</p>
</li>
<li><p><strong>X87SUB</strong> x87lnk    <em>Type</em>: <em>x87lnk</em></p>
<p>x87 80-bit extended precision floating-point subtraction.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG “fsub” asm_special</p>
</li>
<li><p><strong>X87MUL</strong> x87lnk    <em>Type</em>: <em>x87lnk</em></p>
<p>x87 80-bit extended precision multiply.</p>
<p><em>Attributes</em>: arth comm x87 cse
.CG “fmul” asm_special</p>
</li>
<li><p><strong>X87DIV</strong> x87lnk    <em>Type</em>: <em>x87lnk</em></p>
<p>x87 80-bit extended precision divide.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG “fdiv” asm_special</p>
</li>
<li><p><strong>X87CMP</strong> x87lnk stc    <em>Type</em>: <em>x87lnk</em></p>
<p>x87 80-bit extended precision comparison.</p>
<p><em>Attributes</em>: arth null ir cse
.CG “fucomi” asm_special ccmod</p>
</li>
<li><p><strong>X87CMOV</strong> x87lnk x87lnk    <em>Type</em>: <em>irlnk</em></p>
<p>Select op2 if X87CMP test in op1 is satisfied, else op3.</p>
<p><em>Attributes</em>: other null x87 cse
.CG “fcmov” asm_special</p>
</li>
<li><p><strong>X87ARG</strong> lnk    <em>Type</em>: <em>x87lnk</em></p>
<p>Defines an x87 80-bit extended precision value to be passed as an
argument to a function call via memory.
'x87lnk’ points to the value of the argument.
'lnk’ points to the next ARG ILI.</p>
<p><em>Attributes</em>: define null lnk
.CG memarg “fstpt”</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">X87TOINT</span></code></dt><dd><p>Convert an x87 80-bit extended precision value to a signed integer
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87TOUINT</span></code></dt><dd><p>Convert an x87 80-bit extended precision value to an unsigned integer
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87TOKINT</span></code></dt><dd><p>Convert an x87 80-bit extended precision value to a long long integer
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87TOUKINT</span></code></dt><dd><p>Convert an x87 80-bit extended precision value to an unsigned long long integer
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null kr cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87TOSP</span></code></dt><dd><p>Convert an x87 80-bit extended precision value single precision
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null sp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87TODP</span></code></dt><dd><p>Convert an x87 80-bit extended precision value to double precision
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null dp cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87FROMINT</span></code></dt><dd><p>Convert a signed integer to an  x87 80-bit extended precision value
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87FROMUINT</span></code></dt><dd><p>Convert an unsigned integer to an x87 80-bit extended precision value
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87FROMKINT</span></code></dt><dd><p>Convert a long long to an  x87 80-bit extended precision value
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87FROMUKINT</span></code></dt><dd><p>Convert an unsigned long long to an x87 80-bit extended precision value
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87FROMSP</span></code></dt><dd><p>Convert a float to an x87 80-bit extended precision value
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87FROMDP</span></code></dt><dd><p>Convert a double to an x87 80-bit extended precision value
Used by LLVM only.</p>
<p><em>Attributes</em>: arth null x87 cse
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>X87RETURN</strong> stc    <em>Type</em>: <em>x87lnk</em></p>
<p>Define a x87 80-bit extended precision real function result.
Appears twice for complex-valued function results, in which case the
imaginary part is returned first so that the real part is returned on
top of the stack.</p>
<p><em>Attributes</em>: define null trm
.CG terminal asm_nop</p>
</li>
<li><p><strong>X87RESULT</strong> stc    <em>Type</em>: <em>lnk</em></p>
<p>Acquire the x87 80-bit extended precision result of a function call.
Appears twice for complex-valued function calls, in which case the first
acquires the real part and the second acquires the imaginary part.</p>
<p><em>Attributes</em>: define null x87 dom
.CG terminal asm_nop</p>
</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">X87FREE</span></code></p>
<blockquote>
<div><p><em>Attributes</em>: other null trm
.CG terminal notAILI</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">X87CSE</span></code></p>
<blockquote>
<div><p><em>Attributes</em>: arth null x87
.CG notCG</p>
</div></blockquote>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">X87XCH</span></code></dt><dd><p>Exchanges the top of the x87 floating-point register stack with another entry.</p>
<p><em>Attributes</em>: define null x87
.CG CGonly “fxch”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87POP</span></code></dt><dd><p>Pops an entry from the x87 floating-point register stack.</p>
<p><em>Attributes</em>: define null x87
.CG CGonly “fstp” asm_special</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X87DUP</span></code></dt><dd><p>Duplicates an entry on the x87 floating-point register stack.</p>
<p><em>Attributes</em>: define null x87
.CG CGonly “fld” asm_special</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>BCONCUR</strong> lnk    <em>Type</em>: <em>sym</em></p>
<p>Start auto parallel region of an outlined function sym.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">ECONCUR</span></code></dt><dd><p>End auto parallel region of an outlined function sym.</p>
<p><em>Attributes</em>: other null trm
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>HFADD</strong> hplnk    <em>Type</em>: <em>hplnk</em></p>
<p>Half-precision floating-point addition.</p>
<p><em>Attributes</em>: arth comm hp cse
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">HFNEG</span></code></dt><dd><p>Half-precision negation.</p>
<p><em>Attributes</em>: arth null hp cse
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>HFSUB</strong> hplnk    <em>Type</em>: <em>hplnk</em></p>
<p>Half-precision floating-point subtraction.</p>
<p><em>Attributes</em>: arth null hp cse
.CG notCG</p>
</li>
<li><p><strong>HFMUL</strong> hplnk    <em>Type</em>: <em>hplnk</em></p>
<p>Half-precision floating-point multiply.</p>
<p><em>Attributes</em>: arth comm hp cse
.CG notCG</p>
</li>
<li><p><strong>HFDIV</strong> hplnk    <em>Type</em>: <em>hplnk</em></p>
<p>Half-precision divide.</p>
<p><em>Attributes</em>: arth null hp cse
.CG notCG</p>
</li>
<li><p><strong>HFCMP</strong> hplnk stc    <em>Type</em>: <em>hplnk</em></p>
<p>Half float compare with result of true or false.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>HFCMPZ</strong> stc    <em>Type</em>: <em>hplnk</em></p>
<p>Half float compare with zero; result is TRUE or FALSE.</p>
<p><em>Attributes</em>: arth null ir cse
.CG notCG</p>
</li>
<li><p><strong>DFRHP</strong> hp    <em>Type</em>: <em>lnk</em></p>
<p>Define half precision function result.</p>
<p><em>Attributes</em>: define null hp cse
.CG terminal asm_nop</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">HFCON</span></code></dt><dd><p>Half-precision floating-point constant.</p>
<p><em>Attributes</em>: cons null hp cse
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>LDHP</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load half-precision floating value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null hp
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">HP2SP</span></code></dt><dd><p>Half precison to single precision conversion.</p>
<p><em>Attributes</em>: arth null sp
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">SP2HP</span></code></dt><dd><p>Single precison to half precision conversion.</p>
<p><em>Attributes</em>: arth null hp
.CG notCG</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">DP2HP</span></code></dt><dd><p>Double precison to half precision conversion.</p>
<p><em>Attributes</em>: arth null hp
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>STHP</strong> arlnk nme stc    <em>Type</em>: <em>hplnk</em></p>
<p>Store half precision quantity.  ‘stc’ must be MSZ_F2.</p>
<p><em>Attributes</em>: store null trm
.CG notCG</p>
</li>
<li><p><strong>ARGHP</strong> lnk    <em>Type</em>: <em>hplnk</em></p>
<p>Defines a half-precision memory argument.
'hplnk’ points to the register value of the argument.
'lnk’ points to the next ARG ILI.</p>
<p><em>Attributes</em>: define null lnk
.CG notCG</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">CSEHP</span></code></dt><dd><p>Half precision register cse.</p>
<p><em>Attributes</em>: arth null hp
.CG notCG</p>
</dd>
</dl>
<ol class="arabic">
<li><p><strong>HFCJMP</strong> hplnk stc sym    <em>Type</em>: <em>hplnk</em></p>
<p>Half precision compare and jump to the label ‘sym’
if the condition, denoted by stc, is true.</p>
<p><em>Attributes</em>: branch null trm dom
.CG terminal conditional_branch notAILI</p>
</li>
<li><p><strong>HFCJMPZ</strong> stc sym    <em>Type</em>: <em>hplnk</em></p>
<p>Half precision compare with zero and branch to label ‘sym’.</p>
<p><em>Attributes</em>: branch null trm dom
.CG notCG conditional_branch</p>
</li>
<li><p><strong>MVHP</strong> ir    <em>Type</em>: <em>hplnk</em></p>
<p>Move half FP value into specific integer register, ir.</p>
<p><em>Attributes</em>: move null trm
.CG terminal notAILI ‘l’</p>
</li>
<li><p><strong>HFMAX</strong> hplnk    <em>Type</em>: <em>hplnk</em></p>
<p>Half-precision max</p>
<p><em>Attributes</em>: arth comm hp cse
.CG notCG</p>
</li>
<li><p><strong>HFMIN</strong> hplnk    <em>Type</em>: <em>hplnk</em></p>
<p>Half-precision min</p>
<p><em>Attributes</em>: arth comm hp cse
.CG notCG</p>
</li>
<li><p><strong>LDQP</strong> nme stc    <em>Type</em>: <em>arlnk</em></p>
<p>Load quad-precision floating value.  ‘stc’ is not used.</p>
<p><em>Attributes</em>: load null qp
.CG notCG</p>
</li>
<li><p><strong>STQP</strong> arlnk nme stc    <em>Type</em>: <em>qplnk</em></p>
<p>Store quad precision quantity.  ‘stc’ must be MSZ_F16.</p>
<p><em>Attributes</em>: store null trm
.CG notCG</p>
</li>
<li><p><strong>QADD</strong> qplnk    <em>Type</em>: <em>qplnk</em></p>
<p>quad-precision floating-point addition.</p>
<p><em>Attributes</em>: arth comm qp cse
.CG notCG
.so ilitp_atomic.n</p>
</li>
</ol>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">MFENCE</span></code></dt><dd><p>x86 MFENCE instruction.</p>
<p><em>Attributes</em>: other null trm fence
.CG CGonly terminal “mfence”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X86XCHG</span></code></dt><dd><p>x86 XCHG instruction. Used only in AILI, and only with memory operand as destination.
Always immediately followed by a DEF instruction that defines
the same register as the source operand of the XCHG.</p>
<p><em>Attributes</em>: other null ir
.CG CGonly “xchg”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X86XADD</span></code></dt><dd><p>x86 XADD instruction. Use and constraints are same as for XCHG.</p>
<p><em>Attributes</em>: other null ir
.CG CGonly “xadd”</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">X86CMPXCHG</span></code></dt><dd><p>x86 CMPXCHG instruction. Used only in AILI, and only with memory operand as destination.
Always immediately followed by a DEF instruction that defines
the same register as the second source operand (comparand),
which must be one of AL, AX, EAX, RAX.</p>
<p><em>Attributes</em>: other null ir
.CG CGonly “cmpxchg” ccmod</p>
</dd>
</dl>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="ilmtp.html">Appendix IV - ILM Definitions</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="symini.html">Appendix VII - Intrinsics &amp; Generics</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>